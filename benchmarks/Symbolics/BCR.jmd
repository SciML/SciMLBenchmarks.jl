---
title: BCR Symbolic Jacobian
author: Aayush Sabharwal, Bowen Zhu, Chris Rackauckas
---

The following benchmark is of 1122 ODEs with 24388 terms that describe a stiff
chemical reaction network modeling the BCR signaling network from [Barua et
al.](https://doi.org/10.4049/jimmunol.1102003). We use
[`ReactionNetworkImporters`](https://github.com/isaacsas/ReactionNetworkImporters.jl)
to load the BioNetGen model files as a
[Catalyst](https://github.com/SciML/Catalyst.jl) model, and then use
[ModelingToolkit](https://github.com/SciML/ModelingToolkit.jl) to convert the
Catalyst network model to ODEs.

The resultant large model is used to benchmark the time taken to compute a symbolic
jacobian, generate a function to calculate it and call the function.


```julia
using OrdinaryDiffEq, Catalyst, ReactionNetworkImporters,
    TimerOutputs, LinearAlgebra, ModelingToolkit, Chairmarks,
    LinearSolve, Symbolics, SymbolicUtils, SymbolicUtils.Code, SparseArrays, CairoMakie,
    PrettyTables

datadir  = joinpath(dirname(pathof(ReactionNetworkImporters)),"../data/bcr")
const to = TimerOutput()
tf       = 100000.0

# generate ModelingToolkit ODEs
prnbng = loadrxnetwork(BNGNetwork(), joinpath(datadir, "bcr.net"))
show(to)
rn    = complete(prnbng.rn; split = false)
obs = [eq.lhs for eq in observed(rn)]
osys = convert(ODESystem, rn)

rhs = [eq.rhs for eq in full_equations(osys)]
vars = unknowns(osys)
pars = parameters(osys)

SymbolicUtils.ENABLE_HASHCONSING[] = false
@timeit to "Calculate jacobian - without hashconsing" jac_nohc = Symbolics.sparsejacobian(rhs, vars);
SymbolicUtils.ENABLE_HASHCONSING[] = true
SymbolicUtils.toggle_caching!(Symbolics.occursin_info, false)
@timeit to "Calculate jacobian - hashconsing, without caching" jac_hc_nocache = Symbolics.sparsejacobian(rhs, vars);
SymbolicUtils.toggle_caching!(Symbolics.occursin_info, true)
stats = SymbolicUtils.get_stats(Symbolics.occursin_info)
@assert stats.hits == stats.misses == 0
@timeit to "Calculate jacobian - hashconsing and caching" jac_hc_cache = Symbolics.sparsejacobian(rhs, vars);

@assert isequal(jac_nohc, jac_hc_nocache)
@assert isequal(jac_hc_nocache, jac_hc_cache)

jac = jac_hc_cache
args = (vars, pars, ModelingToolkit.get_iv(osys))
# out of place versions run into an error saying the expression is too large
# due to the `SymbolicUtils.Code.create_array` call. `iip_config` prevents it
# from trying to build the function.
kwargs = (; iip_config = (false, true), expression = Val{false})
@timeit to "Build jacobian - no CSE" _, jac_nocse_iip = build_function(jac, args...; cse = false, kwargs...);
@timeit to "Build jacobian - CSE" _, jac_cse_iip = build_function(jac, args...; cse = true, kwargs...);

defs = defaults(osys)
u = Float64[Symbolics.fixpoint_sub(var, defs) for var in vars]
buffer_cse = similar(jac, Float64)
buffer_nocse = similar(jac, Float64)
p = Float64[Symbolics.fixpoint_sub(par, defs) for par in pars]
tt = 0.0

@timeit to "Compile jacobian - CSE" jac_cse_iip(buffer_cse, u, p, tt)
@timeit to "Compute jacobian - CSE" jac_cse_iip(buffer_cse, u, p, tt)

@timeit to "Compile jacobian - no CSE" jac_nocse_iip(buffer_nocse, u, p, tt)
@timeit to "Compute jacobian - no CSE" jac_nocse_iip(buffer_nocse, u, p, tt)

@assert isapprox(buffer_cse, buffer_nocse, rtol = 1e-10)

show(to)
```

We'll also measure scaling.


```julia
function run_and_time!(rhs, vars, pars, iv, u0, p, t0, N, i, jac_times, jac_allocs, build_times, first_call_times, second_call_times)
    outputs = rhs[1:N]
    SymbolicUtils.ENABLE_HASHCONSING[] = false
    jac_result = @be Symbolics.sparsejacobian(outputs, vars)
    jac_times[1][i] = minimum(x -> x.time, jac_result.samples)
    jac_allocs[1][i] = minimum(x -> x.bytes, jac_result.samples)
    jac_nohc = Symbolics.sparsejacobian(outputs, vars)

    SymbolicUtils.ENABLE_HASHCONSING[] = true
    SymbolicUtils.clear_cache!(Symbolics.occursin_info)
    jac_result = @be Symbolics.sparsejacobian(outputs, vars)
    jac_times[2][i] = minimum(x -> x.time, jac_result.samples)
    jac_allocs[2][i] = minimum(x -> x.bytes, jac_result.samples)
    jac_hc = Symbolics.sparsejacobian(outputs, vars)

    @assert isequal(jac_nohc, jac_hc)
    jac = jac_hc
    args = (vars, pars, iv)
    kwargs = (; iip_config = (false, true), expression = Val{false})
    
    build_result = @be build_function(jac, args...; cse = false, kwargs...);
    build_times[1][i] = minimum(x -> x.time, build_result.samples)
    jacfn_nocse = build_function(jac, args...; cse = false, kwargs...)[2]

    build_result = @be build_function(jac, args...; cse = true, kwargs...);
    build_times[2][i] = minimum(x -> x.time, build_result.samples)
    jacfn_cse = build_function(jac, args...; cse = true, kwargs...)[2]

    buffer = similar(jac, Float64)
    call_result = @timed jacfn_nocse(buffer, u0, p, t0)
    first_call_times[1][i] = call_result.time
    call_result = @timed jacfn_cse(buffer, u0, p, t0)
    first_call_times[2][i] = call_result.time

    call_result = @be jacfn_nocse(buffer, u0, p, t0)
    second_call_times[1][i] = minimum(x -> x.time, call_result.samples)
    call_result = @be jacfn_cse(buffer, u0, p, t0)
    second_call_times[2][i] = minimum(x -> x.time, call_result.samples)

    return nothing
end
```

# Run benchmark

```julia
N = [10, 20, 40, 60, 100, 200, 300, 400]
jacobian_times = [zeros(Float64, length(N)), zeros(Float64, length(N))]
jacobian_allocs = copy.(jacobian_times)
# [without_cse_times, with_cse_times]
build_times = copy.(jacobian_times)
first_call_times = copy.(jacobian_times)
second_call_times = copy.(jacobian_times)

iv = ModelingToolkit.get_iv(osys)
run_and_time!(rhs, vars, pars, iv, u, p, tt, 10, 1, jacobian_times, jacobian_allocs, build_times, first_call_times, second_call_times)
for (i, n) in enumerate(N)
    run_and_time!(rhs, vars, pars, iv, u, p, tt, n, i, jacobian_times, jacobian_allocs, build_times, first_call_times, second_call_times)
end
```

# Plot figures

```julia
tabledata = hcat(N, jacobian_times..., jacobian_allocs..., build_times..., first_call_times..., second_call_times...)
header = ["N", "Jacobian time (no hashconsing)", "Jacobian time (hashconsing)", "Jacobian allocated memory (no hashconsing) (B)", "Jacobian allocated memory (hashconsing) (B)", "`build_function` time (no CSE)", "`build_function` time (CSE)", "First call time (no CSE)", "First call time (CSE)", "Second call time (no CSE)", "Second call time (CSE)"]
pretty_table(tabledata; header, backend = Val(:html))
```

```julia
f = Figure(size = (800, 1200));
labels = ["Symbolic jacobian time", "Symbolic jacobian\nallocated memory (B)", "`build_function` time", "First call time", "Second call time"]
times = [jacobian_times, jacobian_allocs, build_times, first_call_times, second_call_times]
for (i, (label, data)) in enumerate(zip(labels, times))
  ax = Axis(f[i, 1], xscale = log10, yscale = log10, ylabel = label, xticks = N)
  l1 = lines!(ax, N, data[1])
  l2 = lines!(ax, N, data[2])
  legend_entries = startswith(label, "Symbolic") ? ["without hashconsing", "with hashconsing"] : ["without CSE", "with CSE"]
  Legend(f[i, 2], [l1, l2], legend_entries)
end
f
```
