---
title: Car Axis, DAE format
author: Polic Marko
---

```julia
using DiffEqDevTools, Sundials, ODEInterfaceDiffEq,
      Plots, DASSL, DASKR
using ModelingToolkit, OrdinaryDiffEq
using ModelingToolkit: t_nounits as t, D_nounits as D
using LinearAlgebra

#= !!! IMPORTANT !!!

      check if ϵ (Hooke law, spring coef),
      and ε (a parameter that appears) 
      from the problem formulation are 
      the same, or diff parameters

=# 


@parameters begin
      M   = 10
      ω   = 10
      L   = 1
      τ   = π/5
      L_0 = 1/2
      h   = 0.1
      ϵ   = 0.01
end


@variables begin
      x_l(t)      # p
      y_l(t)
      x_r(t)
      y_r(t)
      x_b(t)      # bottom point
      y_b(t)
      q1(t)       # q = dp/dt
      q2(t)
      q3(t)
      q4(t)
      λ1(t)
      λ2(t)
      L_l(t)
      L_r(t)
end

eqs = [
      D(x_l) ~ q1
      D(y_l) ~ q2
      D(x_r) ~ q3
      D(y_r) ~ q4
      (ϵ^2*M / 2) * D(q1) ~ (L_0 - L)*x_l/L_l     + λ1*x_b + 2*λ2*(x_l-x_r)
      (ϵ^2*M / 2) * D(q2) ~ (L_0 - L)*y_l/L_l     + λ1*y_b + 2*λ2*(y_l-y_r) - ϵ^2*M/2
      (ϵ^2*M / 2) * D(q3) ~ (L_0 - L)*(x_r - x_b)/L_r      - 2*λ2*(x_l-x_r)
      (ϵ^2*M / 2) * D(q4) ~ (L_0 - L)*(y_r - y_b)/L_r      - 2*λ2*(y_l-y_r) - ϵ^2*M/2
      0 ~ x_l*x_b + y_l*y_b
      0 ~ (x_l-x_r)^2 + (y_l-y_r)^2 - L^2
      L_l ~ sqrt(x_l^2 + y_l^2)
      L_r ~ sqrt((x_r - x_b)^2 + (y_r - y_b)^2)
      x_b ~ sqrt(L^2 - y_b^2)
      y_b ~ h * sin(ω*t)
]

u0 = [x_l  => 0
      y_l  => 1/2
      x_r  => 1
      y_r  => 1/2
      q1   => -1/2
      q2   => 0
      q3   => -1/2
      q4   => 0
      λ1   => 0
      λ2   => 0
      y_b  => 0
      x_b  => 1
      L_l  => 1/2
      L_r  => 1/2
]

@mtkbuild sys = ODESystem(eqs, t)
tspan = (0.0, 3.0)
mtkprob   = ODEProblem(sys, u0, tspan)
ref_sol = solve(mtkprob, Rodas5P(), abstol = 1e-10, reltol = 1e-14)# ->
# retcode:unstable, no matter what solver I try


du = mtkprob.f(mtkprob.u0, mtkprob.p, 0.0)
du0 = D.(unknowns(sys)) .=> du
daeprob = DAEProblem(sys, du0, u0, tspan)
dae_ref_sol = solve(daeprob, IDA(), abstol = 1/10^8, reltol = 1/10^8)


function carAxis(du, u, p, t)
      x_l, y_l, x_r, y_r, q1, q2, q3, q4 = u
    
      M   = 10
      ω   = 10
      L   = 1
      τ   = π/5
      L_0 = 1/2
      h   = 0.1
      ϵ   = 0.01

      y_b = h*sin(ω*t)
      x_b = sqrt(L^2 - y_b^2)

      L_l = sqrt(x_l^2 + y_l^2)
      L_r = sqrt((x_r - x_b)^2 + (y_r - y_b)^2)



      du[1] = q1
      du[2] = q2
      du[3] = q3
      du[4] = q4
      du[5] = (L_0 - L)*x_l/L_l     + λ1*x_b + 2*λ2*(x_l-x_r)
      du[6] = (L_0 - L)*y_l/L_l     + λ1*y_b + 2*λ2*(y_l-y_r) - ϵ^2*M/2
      du[7] = (L_0 - L)*(x_r - x_b)/L_r      - 2*λ2*(x_l-x_r)
      du[8] = (L_0 - L)*(y_r - y_b)/L_r      - 2*λ2*(y_l-y_r) - ϵ^2*M/2
      du[9] = x_l*x_b + y_l*y_b
      du[10]= (x_l-x_r)^2 + (y_l-y_r)^2 - L^2
      nothing
end

K = [ (ϵ^2*M / 2) 0 0 0
      0 (ϵ^2*M / 2) 0 0
      0 0 (ϵ^2*M / 2) 0
      0 0 0 (ϵ^2*M / 2)]


dirMassMatrix =
    Float64.(ModelingToolkit.unwrap.(substitute.(
                [ 1   0   0   0   0    0    0    0
                  0   1   0   0   0    0    0    0
                  0   0   1   0   0    0    0    0
                  0   0   0   1   0    0    0    0
                  0   0   0   0 K[1,1] 0    0    0
                  0   0   0   0   0  K[2,2] 0    0
                  0   0   0   0   0    0  K[3,3] 0
                  0   0   0   0   0    0    0  K[4,4]],
                 (parameters(sys) .=> ModelingToolkit.getdefault.(parameters(sys)),))))
      # this mass matrix may need two bottom rows of just zeros for the alg eq.
mmf = ODEFunction(carAxis, mass_matrix = dirMassMatrix)
mmprob = ODEProblem(mmf, [0.0,0.5,1.0,0.5,-0.5,0.0,-0.5,0.0], tspan)
mm_refsol = solve(mmprob, Rodas5(), reltol = 1e-12, abstol = 1e-12)

probs = [mtkprob,daeprob,mmprob]
refs = [ref_sol,ref_sol,mm_refsol];
```

```julia
plot(ref_sol, idxs = [y₁,y₂,y₃,y₄,y₅,y₆,y₇,y₈])
```


```julia
plot(mm_refsol)
```

## Omissions

`DASSL.dassl())` is omitted because it throws a singularity error.
`rodas()` is too slow at low tolerances.

## High Tolerances

```julia
abstols = 1.0 ./ 10.0 .^ (5:8)
reltols = 1.0 ./ 10.0 .^ (1:4);
setups = [Dict(:prob_choice => 1, :alg=>Rodas4()),
          Dict(:prob_choice => 1, :alg=>FBDF()),
          Dict(:prob_choice => 1, :alg=>QNDF()),
          Dict(:prob_choice => 1, :alg=>rodas()),
          Dict(:prob_choice => 1, :alg=>radau()),
          Dict(:prob_choice => 1, :alg=>RadauIIA5()),
          Dict(:prob_choice => 2, :alg=>DFBDF()),
          Dict(:prob_choice => 2, :alg=>IDA()),
]

wp = WorkPrecisionSet(probs,abstols,reltols,setups;
                      save_everystep=false,appxsol=refs,maxiters=Int(1e5),numruns=10)
plot(wp)
```

```julia
abstols = 1.0 ./ 10.0 .^ (6:8)
reltols = 1.0 ./ 10.0 .^ (2:4);
setups = [Dict(:prob_choice => 1, :alg=>Rosenbrock23()),
          Dict(:prob_choice => 1, :alg=>Rodas4()),
          Dict(:prob_choice => 2, :alg=>IDA()),
          Dict(:prob_choice => 3, :alg=>Rodas5P()),
          Dict(:prob_choice => 3, :alg=>Rodas4()),
          Dict(:prob_choice => 3, :alg=>FBDF()),
          Dict(:prob_choice => 2, :alg=>IDA()),
          Dict(:prob_choice => 2, :alg=>DASKR.daskr()),
          ]
wp = WorkPrecisionSet(probs,abstols,reltols,setups;
                      save_everystep=false,appxsol=refs,maxiters=Int(1e5),numruns=10)
plot(wp)
```

### Timeseries Errors

```julia
abstols = 1.0 ./ 10.0 .^ (5:8)
reltols = 1.0 ./ 10.0 .^ (1:4);
setups = [Dict(:prob_choice => 1, :alg=>Rosenbrock23()),
          Dict(:prob_choice => 1, :alg=>Rodas4()),
          Dict(:prob_choice => 1, :alg=>FBDF()),
          Dict(:prob_choice => 1, :alg=>QNDF()),
          Dict(:prob_choice => 1, :alg=>rodas()),
          Dict(:prob_choice => 1, :alg=>radau()),
          Dict(:prob_choice => 1, :alg=>RadauIIA5()),
          Dict(:prob_choice => 2, :alg=>DFBDF()),
          Dict(:prob_choice => 2, :alg=>IDA()),
          ]
wp = WorkPrecisionSet(probs,abstols,reltols,setups;error_estimate = :l2,
                      save_everystep=false,appxsol=refs,maxiters=Int(1e5),numruns=10)
plot(wp)
```

```julia
abstols = 1.0 ./ 10.0 .^ (6:8)
reltols = 1.0 ./ 10.0 .^ (2:4);
setups = [Dict(:prob_choice => 1, :alg=>Rosenbrock23()),
          Dict(:prob_choice => 1, :alg=>Rodas4()),
          Dict(:prob_choice => 2, :alg=>IDA()),
          Dict(:prob_choice => 3, :alg=>Rodas5P()),
          Dict(:prob_choice => 3, :alg=>Rodas4()),
          Dict(:prob_choice => 3, :alg=>FBDF()),
          Dict(:prob_choice => 2, :alg=>IDA()),
          Dict(:prob_choice => 2, :alg=>DASKR.daskr()),
          ]
wp = WorkPrecisionSet(probs,abstols,reltols,setups;error_estimate = :l2,
                      save_everystep=false,appxsol=refs,maxiters=Int(1e5),numruns=10)
plot(wp)
```

### Low Tolerances

This is the speed at lower tolerances, measuring what's good when accuracy is needed.

```julia
abstols = 1.0 ./ 10.0 .^ (7:12)
reltols = 1.0 ./ 10.0 .^ (4:9)

setups = [Dict(:prob_choice => 1, :alg=>Rodas5P()),
          Dict(:prob_choice => 3, :alg=>Rodas5P()),
          Dict(:prob_choice => 1, :alg=>Rodas4()),
          Dict(:prob_choice => 3, :alg=>Rodas4()),
          Dict(:prob_choice => 1, :alg=>FBDF()),
          Dict(:prob_choice => 1, :alg=>QNDF()),
          Dict(:prob_choice => 1, :alg=>radau()),
          Dict(:prob_choice => 1, :alg=>RadauIIA5()),
          Dict(:prob_choice => 2, :alg=>DFBDF()),
          Dict(:prob_choice => 2, :alg=>IDA()),
          Dict(:prob_choice => 2, :alg=>DASKR.daskr()),
          ]

wp = WorkPrecisionSet(probs,abstols,reltols,setups;
                      save_everystep=false,appxsol=refs,maxiters=Int(1e5),numruns=10)
plot(wp)
```

```julia
wp = WorkPrecisionSet(probs,abstols,reltols,setups;error_estimate = :l2,
                      save_everystep=false,appxsol=refs,maxiters=Int(1e5),numruns=10)
plot(wp)
```

### Conclusion

```julia, echo = false
using SciMLBenchmarks
SciMLBenchmarks.bench_footer(WEAVE_ARGS[:folder],WEAVE_ARGS[:file])
```
