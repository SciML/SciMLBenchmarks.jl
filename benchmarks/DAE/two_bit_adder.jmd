---
title: Two-Bit Adding Unit DAE Work-Precision Diagrams
author: Singh Harsh Rahulkumar
---

This is a benchmark of the Two-Bit Adding Unit, an index-1 DAE of dimension 350
from the IVP Test Set (Bär & Söhnlein 1998, `tba.f`).

The system models a CMOS digital circuit that computes the sum of two 2-bit
binary numbers plus a carry-in:

$$A_1 \cdot 2 + A_0 + B_1 \cdot 2 + B_0 + C_{in} = C \cdot 4 + S_1 \cdot 2 + S_0$$

The circuit consists of ten logical subcircuits (3 NOR gates, 5 ANDOI gates,
1 NAND gate, 1 ORANI gate) plus three additional enhancement transistors in
series. The transistor model is the Shichman–Hodges MOSFET model with
depletion- and enhancement-type devices.

**Variables (350 state variables):**
- 175 charge variables (differential): $Q_1, \ldots, Q_{175}$
- 175 node potentials (algebraic): $V_1, \ldots, V_{175}$

**System structure:**
The charge-driven formulation gives
$$\dot{Q} = f(t, V), \qquad 0 = Q - g(V)$$
where $f$ contains the static currents (resistive + MOSFET drain/source/bulk)
and $g$ is the nonlinear charge function. This is an index-1 DAE.

**Physically relevant outputs (3 signals):**
- $V_{49}$  = $S_0$ (sum bit 0)
- $V_{130}$ = $S_1$ (sum bit 1)
- $V_{148}$ = $C$ (carry out)

**Input signals:** Five periodic pulse waveforms drive the circuit with periods
20, 40, 80, 160, and 320 (scaled time), producing derivative discontinuities
at $t = 0, 5, 10, \ldots, 320$.

Reference: Bär, M. and Söhnlein, K.: Test Set for IVP Solvers,
http://www.dm.uniba.it/~testset/

```julia
using OrdinaryDiffEq, DiffEqDevTools, Sundials, ModelingToolkit, Plots
using DASSL, DASKR
using LinearAlgebra
```

## Physical Constants and MOS Parameters

All parameters are from `tba.f`. Time is scaled by CTIME = 10⁴ and stiffness
by STIFF = 5.

```julia
# --- Scaling ---
const CTIME = 1.0e4
const STIFF = 5.0

# --- MOS Parameters ---
const RGS   = 0.4e2 / (CTIME * STIFF)
const RGD   = 0.4e2 / (CTIME * STIFF)
const RBS   = 0.1e3 / (CTIME * STIFF)
const RBD   = 0.1e3 / (CTIME * STIFF)
const CGS   = 0.6e-4 * CTIME
const CGD   = 0.6e-4 * CTIME
const CBD   = 2.4e-5 * CTIME
const CBS   = 2.4e-5 * CTIME
const DELTA = 0.2e-1
const CURIS = 1.0e-15 * CTIME * STIFF
const VTH   = 25.85
const VDD   = 5.0
const VBB   = -2.5
const CLOAD = 0.0
const COUT  = 2.0e-4 * CTIME - CLOAD
```

## MOSFET Model Functions (Shichman–Hodges)

```julia
"""Voltage-dependent bulk capacitance."""
function CBDBS(V)
    PHIB = 0.87
    if V <= 0.0
        return CBD / sqrt(1.0 - V / PHIB)
    else
        return CBD * (1.0 + V / (2.0 * PHIB))
    end
end

"""pn-junction current: bulk-source."""
function IBS_func(VBS)
    if VBS <= 0.0
        return -CURIS * (exp(VBS / VTH) - 1.0)
    else
        return 0.0
    end
end

"""pn-junction current: bulk-drain."""
function IBD_func(VBD)
    if VBD <= 0.0
        return -CURIS * (exp(VBD / VTH) - 1.0)
    else
        return 0.0
    end
end

"""Get MOS parameters by type: 0=depletion, 1=enhancement, 2=2x series, 3=3x series."""
function mos_params(NED)
    if NED == 0
        return -2.43, 0.2, 1.28, 53.5e-6 * CTIME * STIFF
    elseif NED == 1
        return 0.2, 0.035, 1.01, 4 * 43.7e-6 * CTIME * STIFF
    elseif NED == 2
        return 0.2, 0.035, 1.01, 8 * 43.7e-6 * CTIME * STIFF
    else
        return 0.2, 0.035, 1.01, 12 * 43.7e-6 * CTIME * STIFF
    end
end

"""Drain function for VDS > 0."""
function GDSP(NED, VDS, VGS, VBS)
    VT0, CGAMMA, PHI, BETA = mos_params(NED)
    if PHI - VBS < 0.0 || PHI < 0.0
        return 0.0, true  # error flag
    end
    VTE = VT0 + CGAMMA * (sqrt(PHI - VBS) - sqrt(PHI))
    if VGS - VTE <= 0.0
        return 0.0, false
    elseif VGS - VTE <= VDS
        return -BETA * (VGS - VTE)^2 * (1.0 + DELTA * VDS), false
    else
        return -BETA * VDS * (2.0 * (VGS - VTE) - VDS) * (1.0 + DELTA * VDS), false
    end
end

"""Drain function for VDS < 0."""
function GDSM(NED, VDS, VGD, VBD)
    VT0, CGAMMA, PHI, BETA = mos_params(NED)
    if PHI - VBD < 0.0 || PHI < 0.0
        return 0.0, true  # error flag
    end
    VTE = VT0 + CGAMMA * (sqrt(PHI - VBD) - sqrt(PHI))
    if VGD - VTE <= 0.0
        return 0.0, false
    elseif VGD - VTE <= -VDS
        return BETA * (VGD - VTE)^2 * (1.0 - DELTA * VDS), false
    else
        return -BETA * VDS * (2.0 * (VGD - VTE) + VDS) * (1.0 - DELTA * VDS), false
    end
end

"""Drain current (Shichman–Hodges model)."""
function IDS_func(NED, VDS, VGS, VBS, VGD, VBD)
    if VDS > 0.0
        return GDSP(NED, VDS, VGS, VBS)
    elseif VDS == 0.0
        return 0.0, false
    else
        return GDSM(NED, VDS, VGD, VBD)
    end
end
```

## Input Signal (Periodic Pulse)

```julia
"""
Evaluate periodic pulse signal at time X.

Signal structure: LOW → ramp up (T1) → HIGH (T2) → ramp down (T3) → LOW
"""
function pulse(X, LOW, HIGH, DELAY, T1, T2, T3, PERIOD)
    TIME = mod(X, PERIOD)
    if TIME > DELAY + T1 + T2 + T3
        return LOW, 0.0
    elseif TIME > DELAY + T1 + T2
        VIN = ((HIGH - LOW) / T3) * (DELAY + T1 + T2 + T3 - TIME) + LOW
        return VIN, -(HIGH - LOW) / T3
    elseif TIME > DELAY + T1
        return HIGH, 0.0
    elseif TIME > DELAY
        VIN = ((HIGH - LOW) / T1) * (TIME - DELAY) + LOW
        return VIN, (HIGH - LOW) / T1
    else
        return LOW, 0.0
    end
end
```

## Logic Gate Subcircuit Functions

Each gate computes the static current (right-hand side) for its nodes.

```julia
"""NOR gate: NOT(U1 OR U2). Nodes I..I+12."""
function nor_gate!(F, Y, I, U1, U2, U1D, U2D)
    ids_dep, _ = IDS_func(0, Y[I+1]-Y[I], Y[I+4]-Y[I], Y[I+2]-Y[I+4], Y[I+4]-Y[I+1], Y[I+3]-VDD)
    F[I]   = -(Y[I]-Y[I+4])/RGS - ids_dep
    F[I+1] = -(Y[I+1]-VDD)/RGD + ids_dep
    F[I+2] = -(Y[I+2]-VBB)/RBS + IBS_func(Y[I+2]-Y[I+4])
    F[I+3] = -(Y[I+3]-VBB)/RBD + IBD_func(Y[I+3]-VDD)
    # Result node I+4
    F[I+4] = -(Y[I+4]-Y[I])/RGS - IBS_func(Y[I+2]-Y[I+4]) -
             (Y[I+4]-Y[I+6])/RGD - IBD_func(Y[I+8]-Y[I+4]) -
             (Y[I+4]-Y[I+10])/RGD - IBD_func(Y[I+12]-Y[I+4])
    ids_val, _ = IDS_func(1, Y[I+6]-Y[I+5], U1-Y[I+5], Y[I+7], U1-Y[I+6], Y[I+8]-Y[I+4])
    F[I+5] = CGS*U1D - Y[I+5]/RGS - ids_val
    F[I+6] = CGD*U1D - (Y[I+6]-Y[I+4])/RGD + ids_val
    F[I+7] = -(Y[I+7]-VBB)/RBS + IBS_func(Y[I+7])
    F[I+8] = -(Y[I+8]-VBB)/RBD + IBD_func(Y[I+8]-Y[I+4])
    ids_val, _ = IDS_func(1, Y[I+10]-Y[I+9], U2-Y[I+9], Y[I+11], U2-Y[I+10], Y[I+12]-Y[I+4])
    F[I+9]  = CGS*U2D - Y[I+9]/RGS - ids_val
    F[I+10] = CGD*U2D - (Y[I+10]-Y[I+4])/RGD + ids_val
    F[I+11] = -(Y[I+11]-VBB)/RBS + IBS_func(Y[I+11])
    F[I+12] = -(Y[I+12]-VBB)/RBD + IBD_func(Y[I+12]-Y[I+4])
end

"""ANDOI gate: NOT(U1 OR (U2 AND U3)). Nodes I..I+17."""
function andoi_gate!(F, Y, I, U1, U2, U3, U1D, U2D, U3D)
    ids_val, _ = IDS_func(0, Y[I+1]-Y[I], Y[I+4]-Y[I], Y[I+2]-Y[I+4], Y[I+4]-Y[I+1], Y[I+3]-VDD)
    F[I]   = -(Y[I]-Y[I+4])/RGS - ids_val
    F[I+1] = -(Y[I+1]-VDD)/RGD + ids_val
    F[I+2] = -(Y[I+2]-VBB)/RBS + IBS_func(Y[I+2]-Y[I+4])
    F[I+3] = -(Y[I+3]-VBB)/RBD + IBD_func(Y[I+3]-VDD)
    # Result node I+4
    F[I+4] = -(Y[I+4]-Y[I])/RGS - IBS_func(Y[I+2]-Y[I+4]) -
             (Y[I+4]-Y[I+6])/RGD - IBD_func(Y[I+8]-Y[I+4]) -
             (Y[I+4]-Y[I+10])/RGD - IBD_func(Y[I+12]-Y[I+4])
    ids_val, _ = IDS_func(1, Y[I+6]-Y[I+5], U1-Y[I+5], Y[I+7], U1-Y[I+6], Y[I+8]-Y[I+4])
    F[I+5] = CGS*U1D - Y[I+5]/RGS - ids_val
    F[I+6] = CGD*U1D - (Y[I+6]-Y[I+4])/RGD + ids_val
    F[I+7] = -(Y[I+7]-VBB)/RBS + IBS_func(Y[I+7])
    F[I+8] = -(Y[I+8]-VBB)/RBD + IBD_func(Y[I+8]-Y[I+4])
    ids_val, _ = IDS_func(2, Y[I+10]-Y[I+9], U2-Y[I+9], Y[I+11]-Y[I+13], U2-Y[I+10], Y[I+12]-Y[I+4])
    F[I+9]  = CGS*U2D - (Y[I+9]-Y[I+13])/RGS - ids_val
    F[I+10] = CGD*U2D - (Y[I+10]-Y[I+4])/RGD + ids_val
    F[I+11] = -(Y[I+11]-VBB)/RBS + IBS_func(Y[I+11]-Y[I+13])
    F[I+12] = -(Y[I+12]-VBB)/RBD + IBD_func(Y[I+12]-Y[I+4])
    # Coupling node I+13
    F[I+13] = -(Y[I+13]-Y[I+9])/RGS - IBS_func(Y[I+11]-Y[I+13]) -
              (Y[I+13]-Y[I+15])/RGD - IBD_func(Y[I+17]-Y[I+13])
    ids_val, _ = IDS_func(2, Y[I+15]-Y[I+14], U3-Y[I+14], Y[I+16], U3-Y[I+15], Y[I+17]-Y[I+13])
    F[I+14] = CGS*U3D - Y[I+14]/RGS - ids_val
    F[I+15] = CGD*U3D - (Y[I+15]-Y[I+13])/RGD + ids_val
    F[I+16] = -(Y[I+16]-VBB)/RBS + IBS_func(Y[I+16])
    F[I+17] = -(Y[I+17]-VBB)/RBD + IBD_func(Y[I+17]-Y[I+13])
end

"""ANDOI gate with capacitive coupling at result node (for TBA output node 148).
   Nodes I..I+17, with extra coupling to nodes 163, 165."""
function andoip_gate!(F, Y, I, U1, U2, U3, U1D, U2D, U3D)
    ids_val, _ = IDS_func(0, Y[I+1]-Y[I], Y[I+4]-Y[I], Y[I+2]-Y[I+4], Y[I+4]-Y[I+1], Y[I+3]-VDD)
    F[I]   = -(Y[I]-Y[I+4])/RGS - ids_val
    F[I+1] = -(Y[I+1]-VDD)/RGD + ids_val
    F[I+2] = -(Y[I+2]-VBB)/RBS + IBS_func(Y[I+2]-Y[I+4])
    F[I+3] = -(Y[I+3]-VBB)/RBD + IBD_func(Y[I+3]-VDD)
    # Result node I+4, extra coupling to nodes 163, 165
    F[I+4] = -(Y[I+4]-Y[I])/RGS - IBS_func(Y[I+2]-Y[I+4]) -
             (Y[I+4]-Y[I+6])/RGD - IBD_func(Y[I+8]-Y[I+4]) -
             (Y[I+4]-Y[I+10])/RGD - IBD_func(Y[I+12]-Y[I+4]) -
             (Y[I+4]-Y[163])/RGD - IBD_func(Y[165]-Y[I+4])
    ids_val, _ = IDS_func(1, Y[I+6]-Y[I+5], U1-Y[I+5], Y[I+7], U1-Y[I+6], Y[I+8]-Y[I+4])
    F[I+5] = CGS*U1D - Y[I+5]/RGS - ids_val
    F[I+6] = CGD*U1D - (Y[I+6]-Y[I+4])/RGD + ids_val
    F[I+7] = -(Y[I+7]-VBB)/RBS + IBS_func(Y[I+7])
    F[I+8] = -(Y[I+8]-VBB)/RBD + IBD_func(Y[I+8]-Y[I+4])
    ids_val, _ = IDS_func(2, Y[I+10]-Y[I+9], U2-Y[I+9], Y[I+11]-Y[I+13], U2-Y[I+10], Y[I+12]-Y[I+4])
    F[I+9]  = CGS*U2D - (Y[I+9]-Y[I+13])/RGS - ids_val
    F[I+10] = CGD*U2D - (Y[I+10]-Y[I+4])/RGD + ids_val
    F[I+11] = -(Y[I+11]-VBB)/RBS + IBS_func(Y[I+11]-Y[I+13])
    F[I+12] = -(Y[I+12]-VBB)/RBD + IBD_func(Y[I+12]-Y[I+4])
    # Coupling node I+13
    F[I+13] = -(Y[I+13]-Y[I+9])/RGS - IBS_func(Y[I+11]-Y[I+13]) -
              (Y[I+13]-Y[I+15])/RGD - IBD_func(Y[I+17]-Y[I+13])
    ids_val, _ = IDS_func(2, Y[I+15]-Y[I+14], U3-Y[I+14], Y[I+16], U3-Y[I+15], Y[I+17]-Y[I+13])
    F[I+14] = CGS*U3D - Y[I+14]/RGS - ids_val
    F[I+15] = CGD*U3D - (Y[I+15]-Y[I+13])/RGD + ids_val
    F[I+16] = -(Y[I+16]-VBB)/RBS + IBS_func(Y[I+16])
    F[I+17] = -(Y[I+17]-VBB)/RBD + IBD_func(Y[I+17]-Y[I+13])
end

"""NAND gate: NOT(U1 AND U2). Nodes I..I+13."""
function nand_gate!(F, Y, I, U1, U2, U1D, U2D)
    ids_val, _ = IDS_func(0, Y[I+1]-Y[I], Y[I+4]-Y[I], Y[I+2]-Y[I+4], Y[I+4]-Y[I+1], Y[I+3]-VDD)
    F[I]   = -(Y[I]-Y[I+4])/RGS - ids_val
    F[I+1] = -(Y[I+1]-VDD)/RGD + ids_val
    F[I+2] = -(Y[I+2]-VBB)/RBS + IBS_func(Y[I+2]-Y[I+4])
    F[I+3] = -(Y[I+3]-VBB)/RBD + IBD_func(Y[I+3]-VDD)
    # Result node I+4
    F[I+4] = -(Y[I+4]-Y[I])/RGS - IBS_func(Y[I+2]-Y[I+4]) -
             (Y[I+4]-Y[I+6])/RGD - IBD_func(Y[I+8]-Y[I+4])
    ids_val, _ = IDS_func(2, Y[I+6]-Y[I+5], U1-Y[I+5], Y[I+7]-Y[I+9], U1-Y[I+6], Y[I+8]-Y[I+4])
    F[I+5] = CGS*U1D - (Y[I+5]-Y[I+9])/RGS - ids_val
    F[I+6] = CGD*U1D - (Y[I+6]-Y[I+4])/RGD + ids_val
    F[I+7] = -(Y[I+7]-VBB)/RBS + IBS_func(Y[I+7]-Y[I+9])
    F[I+8] = -(Y[I+8]-VBB)/RBD + IBD_func(Y[I+8]-Y[I+4])
    # Coupling node I+9
    F[I+9]  = -(Y[I+9]-Y[I+5])/RGS - IBS_func(Y[I+7]-Y[I+9]) -
              (Y[I+9]-Y[I+11])/RGD - IBD_func(Y[I+13]-Y[I+9])
    ids_val, _ = IDS_func(2, Y[I+11]-Y[I+10], U2-Y[I+10], Y[I+12], U2-Y[I+11], Y[I+13]-Y[I+9])
    F[I+10] = CGS*U2D - Y[I+10]/RGS - ids_val
    F[I+11] = CGD*U2D - (Y[I+11]-Y[I+9])/RGD + ids_val
    F[I+12] = -(Y[I+12]-VBB)/RBS + IBS_func(Y[I+12])
    F[I+13] = -(Y[I+13]-VBB)/RBD + IBD_func(Y[I+13]-Y[I+9])
end

"""ORANI gate: NOT(U1 AND (U2 OR U3)). Nodes I..I+17."""
function orani_gate!(F, Y, I, U1, U2, U3, U1D, U2D, U3D)
    ids_val, _ = IDS_func(0, Y[I+1]-Y[I], Y[I+4]-Y[I], Y[I+2]-Y[I+4], Y[I+4]-Y[I+1], Y[I+3]-VDD)
    F[I]   = -(Y[I]-Y[I+4])/RGS - ids_val
    F[I+1] = -(Y[I+1]-VDD)/RGD + ids_val
    F[I+2] = -(Y[I+2]-VBB)/RBS + IBS_func(Y[I+2]-Y[I+4])
    F[I+3] = -(Y[I+3]-VBB)/RBD + IBD_func(Y[I+3]-VDD)
    # Result node I+4
    F[I+4] = -(Y[I+4]-Y[I])/RGS - IBS_func(Y[I+2]-Y[I+4]) -
             (Y[I+4]-Y[I+6])/RGD - IBD_func(Y[I+8]-Y[I+4])
    ids_val, _ = IDS_func(2, Y[I+6]-Y[I+5], U1-Y[I+5], Y[I+7]-Y[I+9], U1-Y[I+6], Y[I+8]-Y[I+4])
    F[I+5] = CGS*U1D - (Y[I+5]-Y[I+9])/RGS - ids_val
    F[I+6] = CGD*U1D - (Y[I+6]-Y[I+4])/RGD + ids_val
    F[I+7] = -(Y[I+7]-VBB)/RBS + IBS_func(Y[I+7]-Y[I+9])
    F[I+8] = -(Y[I+8]-VBB)/RBD + IBD_func(Y[I+8]-Y[I+4])
    # Coupling node I+9
    F[I+9]  = -(Y[I+9]-Y[I+5])/RGS - IBS_func(Y[I+7]-Y[I+9]) -
              (Y[I+9]-Y[I+11])/RGD - IBD_func(Y[I+13]-Y[I+9]) -
              (Y[I+9]-Y[I+15])/RGD - IBD_func(Y[I+17]-Y[I+9])
    ids_val, _ = IDS_func(2, Y[I+11]-Y[I+10], U2-Y[I+10], Y[I+12], U2-Y[I+11], Y[I+13]-Y[I+9])
    F[I+10] = CGS*U2D - Y[I+10]/RGS - ids_val
    F[I+11] = CGD*U2D - (Y[I+11]-Y[I+9])/RGD + ids_val
    F[I+12] = -(Y[I+12]-VBB)/RBS + IBS_func(Y[I+12])
    F[I+13] = -(Y[I+13]-VBB)/RBD + IBD_func(Y[I+13]-Y[I+9])
    ids_val, _ = IDS_func(2, Y[I+15]-Y[I+14], U3-Y[I+14], Y[I+16], U3-Y[I+15], Y[I+17]-Y[I+9])
    F[I+14] = CGS*U3D - Y[I+14]/RGS - ids_val
    F[I+15] = CGD*U3D - (Y[I+15]-Y[I+9])/RGD + ids_val
    F[I+16] = -(Y[I+16]-VBB)/RBS + IBS_func(Y[I+16])
    F[I+17] = -(Y[I+17]-VBB)/RBD + IBD_func(Y[I+17]-Y[I+9])
end
```

## Static Current Function FCN (Right-Hand Side)

The full right-hand side assembles all ten subcircuits plus three additional
enhancement transistors.

```julia
"""Compute static currents F[1:175] from node potentials Y[1:175] at time X."""
function FCN!(F, X, Y)
    # Input signals
    V1,  V1D  = pulse(X, 0.0, 5.0, 0.0,   5.0, 5.0,  5.0, 20.0)
    V2,  V2D  = pulse(X, 0.0, 5.0, 10.0,  5.0, 15.0, 5.0, 40.0)
    V3,  V3D  = pulse(X, 0.0, 5.0, 30.0,  5.0, 35.0, 5.0, 80.0)
    V4,  V4D  = pulse(X, 0.0, 5.0, 70.0,  5.0, 75.0, 5.0, 160.0)
    CIN, CIND = pulse(X, 0.0, 5.0, 150.0, 5.0, 155.0, 5.0, 320.0)

    # NOR-gate 1: nodes 1–13
    nor_gate!(F, Y, 1, V1, V2, V1D, V2D)
    # ANDOI-gate 1: nodes 14–31
    andoi_gate!(F, Y, 14, Y[5], V2, V1, 0.0, V2D, V1D)
    # NOR-gate 2: nodes 32–44
    nor_gate!(F, Y, 32, Y[18], CIN, 0.0, CIND)
    # ANDOI-gate 2: nodes 45–62
    andoi_gate!(F, Y, 45, Y[36], CIN, Y[18], 0.0, CIND, 0.0)
    # ANDOI-gate 3: nodes 63–80
    andoi_gate!(F, Y, 63, Y[5], CIN, Y[18], 0.0, CIND, 0.0)
    # NOR-gate 3: nodes 81–93
    nor_gate!(F, Y, 81, V3, V4, V3D, V4D)
    # ANDOI-gate 4: nodes 94–111
    andoi_gate!(F, Y, 94, Y[85], V4, V3, 0.0, V4D, V3D)
    # NAND-gate: nodes 112–125
    nand_gate!(F, Y, 112, Y[67], Y[98], 0.0, 0.0)
    # ORANI-gate 1: nodes 126–143
    orani_gate!(F, Y, 126, Y[116], Y[67], Y[98], 0.0, 0.0, 0.0)
    # ANDOI-gate 5 (capacitive coupling): nodes 144–161
    andoip_gate!(F, Y, 144, Y[85], Y[5], Y[98], 0.0, 0.0, 0.0)

    # Three additional enhancement transistors in series (nodes 162–175)
    ids_val, _ = IDS_func(3, Y[163]-Y[162], Y[98]-Y[162], Y[164]-Y[166], Y[98]-Y[163], Y[165]-Y[148])
    F[162] = -(Y[162]-Y[166])/RGS - ids_val
    F[163] = -(Y[163]-Y[148])/RGD + ids_val
    F[164] = -(Y[164]-VBB)/RBS + IBS_func(Y[164]-Y[166])
    F[165] = -(Y[165]-VBB)/RBD + IBD_func(Y[165]-Y[148])
    F[166] = -IBS_func(Y[164]-Y[166]) - (Y[166]-Y[162])/RGS -
              IBD_func(Y[170]-Y[166]) - (Y[166]-Y[168])/RGD

    ids_val, _ = IDS_func(3, Y[168]-Y[167], Y[18]-Y[167], Y[169]-Y[171], Y[18]-Y[168], Y[170]-Y[166])
    F[167] = -(Y[167]-Y[171])/RGS - ids_val
    F[168] = -(Y[168]-Y[166])/RGD + ids_val
    F[169] = -(Y[169]-VBB)/RBS + IBS_func(Y[169]-Y[171])
    F[170] = -(Y[170]-VBB)/RBD + IBD_func(Y[170]-Y[166])
    F[171] = -IBS_func(Y[169]-Y[171]) - (Y[171]-Y[167])/RGS -
              IBD_func(Y[175]-Y[171]) - (Y[171]-Y[173])/RGD

    ids_val, _ = IDS_func(3, Y[173]-Y[172], CIN-Y[172], Y[174], CIN-Y[173], Y[175]-Y[171])
    F[172] = CGS*CIND - Y[172]/RGS - ids_val
    F[173] = CGD*CIND - (Y[173]-Y[171])/RGD + ids_val
    F[174] = -(Y[174]-VBB)/RBS + IBS_func(Y[174])
    F[175] = -(Y[175]-VBB)/RBD + IBD_func(Y[175]-Y[171])
end
```

## Charge Function GCN

```julia
"""Charge function for NOR gate. Nodes I..I+12."""
function dnor!(G, U, I)
    G[I]    += CGS*(U[I]-U[I+4])
    G[I+1]  += CGD*(U[I+1]-U[I+4])
    G[I+2]  += CBDBS(U[I+2]-U[I+4])*(U[I+2]-U[I+4])
    G[I+3]  += CBDBS(U[I+3]-VDD)*U[I+3]
    G[I+4]  += CGS*(U[I+4]-U[I]) + CGD*(U[I+4]-U[I+1]) +
               CBDBS(U[I+2]-U[I+4])*(U[I+4]-U[I+2]) +
               CBDBS(U[I+8]-U[I+4])*(U[I+4]-U[I+8]) +
               CBDBS(U[I+12]-U[I+4])*(U[I+4]-U[I+12]) +
               CLOAD*U[I+4]
    G[I+5]  += CGS*U[I+5]
    G[I+6]  += CGD*U[I+6]
    G[I+7]  += CBDBS(U[I+7])*U[I+7]
    G[I+8]  += CBDBS(U[I+8]-U[I+4])*(U[I+8]-U[I+4])
    G[I+9]  += CGS*U[I+9]
    G[I+10] += CGD*U[I+10]
    G[I+11] += CBDBS(U[I+11])*U[I+11]
    G[I+12] += CBDBS(U[I+12]-U[I+4])*(U[I+12]-U[I+14])
end

"""Charge function for ANDOI gate. Nodes I..I+17."""
function dandoi!(G, U, I)
    G[I]     += CGS*(U[I]-U[I+4])
    G[I+1]   += CGD*(U[I+1]-U[I+4])
    G[I+2]   += CBDBS(U[I+2]-U[I+4])*(U[I+2]-U[I+4])
    G[I+3]   += CBDBS(U[I+3]-VDD)*U[I+3]
    G[I+4]   += CGS*(U[I+4]-U[I]) + CGD*(U[I+4]-U[I+1]) +
                CBDBS(U[I+2]-U[I+4])*(U[I+4]-U[I+2]) +
                CBDBS(U[I+8]-U[I+4])*(U[I+4]-U[I+8]) +
                CBDBS(U[I+12]-U[I+4])*(U[I+4]-U[I+12]) +
                CLOAD*U[I+4]
    G[I+5]   += CGS*U[I+5]
    G[I+6]   += CGD*U[I+6]
    G[I+7]   += CBDBS(U[I+7])*U[I+7]
    G[I+8]   += CBDBS(U[I+8]-U[I+4])*(U[I+8]-U[I+4])
    G[I+9]   += CGS*U[I+9]
    G[I+10]  += CGD*U[I+10]
    G[I+11]  += CBDBS(U[I+11]-U[I+13])*(U[I+11]-U[I+13])
    G[I+12]  += CBDBS(U[I+12]-U[I+4])*(U[I+12]-U[I+4])
    G[I+13]  += CBDBS(U[I+11]-U[I+13])*(U[I+13]-U[I+11]) +
                CBDBS(U[I+17]-U[I+13])*(U[I+13]-U[I+17]) +
                CLOAD*U[I+13]
    G[I+14]  += CGS*U[I+14]
    G[I+15]  += CGD*U[I+15]
    G[I+16]  += CBDBS(U[I+16])*U[I+16]
    G[I+17]  += CBDBS(U[I+17]-U[I+13])*(U[I+17]-U[I+13])
end

"""Charge function for NAND gate. Nodes I..I+13."""
function dnand!(G, U, I)
    G[I]     += CGS*(U[I]-U[I+4])
    G[I+1]   += CGD*(U[I+1]-U[I+4])
    G[I+2]   += CBDBS(U[I+2]-U[I+4])*(U[I+2]-U[I+4])
    G[I+3]   += CBDBS(U[I+3]-VDD)*U[I+3]
    G[I+4]   += CGS*(U[I+4]-U[I]) + CGD*(U[I+4]-U[I+1]) +
                CBDBS(U[I+2]-U[I+4])*(U[I+4]-U[I+2]) +
                CBDBS(U[I+8]-U[I+4])*(U[I+4]-U[I+8]) +
                CLOAD*U[I+4]
    G[I+5]   += CGS*U[I+5]
    G[I+6]   += CGD*U[I+6]
    G[I+7]   += CBDBS(U[I+7]-U[I+9])*(U[I+7]-U[I+9])
    G[I+8]   += CBDBS(U[I+8]-U[I+4])*(U[I+8]-U[I+4])
    G[I+9]   += CBDBS(U[I+7]-U[I+9])*(U[I+9]-U[I+7]) +
                CBDBS(U[I+13]-U[I+9])*(U[I+9]-U[I+13]) +
                CLOAD*U[I+9]
    G[I+10]  += CGS*U[I+10]
    G[I+11]  += CGD*U[I+11]
    G[I+12]  += CBDBS(U[I+12])*U[I+12]
    G[I+13]  += CBDBS(U[I+13]-U[I+9])*(U[I+13]-U[I+9])
end

"""Charge function for ORANI gate. Nodes I..I+17."""
function dorani!(G, U, I)
    G[I]     += CGS*(U[I]-U[I+4])
    G[I+1]   += CGD*(U[I+1]-U[I+4])
    G[I+2]   += CBDBS(U[I+2]-U[I+4])*(U[I+2]-U[I+4])
    G[I+3]   += CBDBS(U[I+3]-VDD)*U[I+3]
    G[I+4]   += CGS*(U[I+4]-U[I]) + CGD*(U[I+4]-U[I+1]) +
                CBDBS(U[I+2]-U[I+4])*(U[I+4]-U[I+2]) +
                CBDBS(U[I+8]-U[I+4])*(U[I+4]-U[I+8]) +
                CLOAD*U[I+4]
    G[I+5]   += CGS*U[I+5]
    G[I+6]   += CGD*U[I+6]
    G[I+7]   += CBDBS(U[I+7]-U[I+9])*(U[I+7]-U[I+9])
    G[I+8]   += CBDBS(U[I+8]-U[I+4])*(U[I+8]-U[I+4])
    G[I+9]   += CBDBS(U[I+7]-U[I+9])*(U[I+9]-U[I+7]) +
                CBDBS(U[I+13]-U[I+9])*(U[I+9]-U[I+13]) +
                CBDBS(U[I+17]-U[I+9])*(U[I+9]-U[I+17]) +
                CLOAD*U[I+9]
    G[I+10]  += CGS*U[I+10]
    G[I+11]  += CGD*U[I+11]
    G[I+12]  += CBDBS(U[I+12])*U[I+12]
    G[I+13]  += CBDBS(U[I+13]-U[I+9])*(U[I+13]-U[I+9])
    G[I+14]  += CGS*U[I+14]
    G[I+15]  += CGD*U[I+15]
    G[I+16]  += CBDBS(U[I+16])*U[I+16]
    G[I+17]  += CBDBS(U[I+17]-U[I+9])*(U[I+17]-U[I+9])
end

"""Full charge function G[1:175] from node potentials U[1:175]."""
function GCN!(G, U)
    fill!(G, 0.0)

    # Ten logical subcircuits
    dnor!(G, U, 1)
    dandoi!(G, U, 14)
    dnor!(G, U, 32)
    dandoi!(G, U, 45)
    dandoi!(G, U, 63)
    dnor!(G, U, 81)
    dandoi!(G, U, 94)
    dnand!(G, U, 112)
    dorani!(G, U, 126)
    dandoi!(G, U, 144)

    # Capacitive coupling: result node NOR-gate 1 (node 5)
    G[5]  += CGS*(U[5]-U[19]) + CGD*(U[5]-U[20]) +
             CGS*(U[5]-U[68]) + CGD*(U[5]-U[69]) +
             CGS*(U[5]-U[153]) + CGD*(U[5]-U[154])
    G[19]  -= CGS*U[5]
    G[20]  -= CGD*U[5]
    G[68]  -= CGS*U[5]
    G[69]  -= CGD*U[5]
    G[153] -= CGS*U[5]
    G[154] -= CGD*U[5]

    # Capacitive coupling: result node ANDOI-gate 1 (node 18)
    G[18] += CGS*(U[18]-U[37]) + CGD*(U[18]-U[38]) +
             CGS*(U[18]-U[59]) + CGD*(U[18]-U[60]) +
             CGS*(U[18]-U[77]) + CGD*(U[18]-U[78]) +
             CGS*(U[18]-U[167]) + CGD*(U[18]-U[168])
    G[37]  -= CGS*U[18]
    G[38]  -= CGD*U[18]
    G[59]  -= CGS*U[18]
    G[60]  -= CGD*U[18]
    G[77]  -= CGS*U[18]
    G[78]  -= CGD*U[18]

    # Capacitive coupling: result node NOR-gate 2 (node 36)
    G[36] += CGS*(U[36]-U[50]) + CGD*(U[36]-U[51])
    G[50]  -= CGS*U[36]
    G[51]  -= CGD*U[36]

    # Capacitive coupling: result node ANDOI-gate 2 = S0 (node 49)
    G[49] += COUT*U[49]

    # Capacitive coupling: result node ANDOI-gate 3 (node 67)
    G[67] += CGS*(U[67]-U[117]) + CGD*(U[67]-U[118]) +
             CGS*(U[67]-U[136]) + CGD*(U[67]-U[137])
    G[117] -= CGS*U[67]
    G[118] -= CGD*U[67]
    G[136] -= CGS*U[67]
    G[137] -= CGD*U[67]

    # Capacitive coupling: result node NOR-gate 3 (node 85)
    G[85] += CGS*(U[85]-U[99]) + CGD*(U[85]-U[100]) +
             CGS*(U[85]-U[149]) + CGD*(U[85]-U[150])
    G[99]  -= CGS*U[85]
    G[100] -= CGD*U[85]
    G[149] -= CGS*U[85]
    G[150] -= CGD*U[85]

    # Capacitive coupling: result node ANDOI-gate 4 (node 98)
    G[98] += CGS*(U[98]-U[122]) + CGD*(U[98]-U[123]) +
             CGS*(U[98]-U[140]) + CGD*(U[98]-U[141]) +
             CGS*(U[98]-U[158]) + CGD*(U[98]-U[159]) +
             CGS*(U[98]-U[162]) + CGD*(U[98]-U[163])
    G[122] -= CGS*U[98]
    G[123] -= CGD*U[98]
    G[140] -= CGS*U[98]
    G[141] -= CGD*U[98]
    G[158] -= CGS*U[98]
    G[159] -= CGD*U[98]

    # Capacitive coupling: result node NAND-gate (node 116)
    G[116] += CGS*(U[116]-U[131]) + CGD*(U[116]-U[132])
    G[131] -= CGS*U[116]
    G[132] -= CGD*U[116]

    # Capacitive coupling: result node ORANI-gate = S1 (node 130)
    G[130] += COUT*U[130]

    # Capacitive coupling: result ANDOI-gate 5 = C_invers (node 148)
    G[148] += CBDBS(U[165]-U[148])*(U[148]-U[165]) + COUT*U[148]

    # Three additional transistors
    G[162] += CGS*(U[162]-U[98])
    G[163] += CGD*(U[163]-U[98])
    G[164] += CBDBS(U[164]-U[166])*(U[164]-U[166])
    G[165] += CBDBS(U[165]-U[148])*(U[165]-U[148])
    G[166] += CBDBS(U[164]-U[166])*(U[166]-U[164]) +
              CBDBS(U[170]-U[166])*(U[166]-U[170]) +
              CLOAD*U[166]
    G[167] += CGS*(U[167]-U[18])
    G[168] += CGD*(U[168]-U[18])
    G[169] += CBDBS(U[169]-U[171])*(U[169]-U[171])
    G[170] += CBDBS(U[170]-U[166])*(U[170]-U[166])
    G[171] += CBDBS(U[169]-U[171])*(U[171]-U[169]) +
              CBDBS(U[175]-U[171])*(U[171]-U[175]) +
              CLOAD*U[171]
    G[172] += CGS*U[172]
    G[173] += CGD*U[173]
    G[174] += CBDBS(U[174])*U[174]
    G[175] += CBDBS(U[175]-U[171])*(U[175]-U[171])
end
```

## Consistent Initial Conditions

From `init` subroutine in `tba.f`. The initial voltage vector U(1:175) is
provided, then `y[1:175] = GCN(U)` (charges) and `y[176:350] = U` (potentials).

```julia
function tba_initial_conditions()
    U = zeros(175)
    U[1]   =  4.999999999996544;  U[2]   =  4.999999999999970
    U[3]   = -2.499999999999975;  U[4]   = -2.499999999999975
    U[5]   =  4.999999999996514;  U[6]   =  0.000000000000000
    U[7]   =  4.999999999996514;  U[8]   = -2.499999999999991
    U[9]   = -2.499999999999975;  U[10]  =  0.000000000000000
    U[11]  =  4.999999999996514;  U[12]  = -2.499999999999991
    U[13]  = -2.499999999999975;  U[14]  =  0.215858486765796
    U[15]  =  4.988182208251953;  U[16]  = -2.499999999999990
    U[17]  = -2.499999999999975;  U[18]  =  0.204040695017748
    U[19]  =  0.011817791748026;  U[20]  =  0.192222903269723
    U[21]  = -2.499999999999991;  U[22]  = -2.499999999999990
    U[23]  = -0.228160951881239;  U[24]  =  0.204040695017748
    U[25]  = -2.499999999999992;  U[26]  = -2.499999999999990
    U[27]  = -0.228160951881241;  U[28]  =  0.000000000000000
    U[29]  = -0.228160951881239;  U[30]  = -2.499999999999991
    U[31]  = -2.499999999999992;  U[32]  =  4.999999999996547
    U[33]  =  4.999999999999970;  U[34]  = -2.499999999999975
    U[35]  = -2.499999999999975;  U[36]  =  4.999999999996517
    U[37]  =  0.000000000000000;  U[38]  =  4.999999999996517
    U[39]  = -2.499999999999991;  U[40]  = -2.499999999999975
    U[41]  =  0.000000000000000;  U[42]  =  4.999999999996517
    U[43]  = -2.499999999999991;  U[44]  = -2.499999999999975
    U[45]  =  0.215858484247529;  U[46]  =  4.988182208251953
    U[47]  = -2.499999999999990;  U[48]  = -2.499999999999975
    U[49]  =  0.204040692499482;  U[50]  =  0.011817791748035
    U[51]  =  0.192222900751447;  U[52]  = -2.499999999999991
    U[53]  = -2.499999999999990;  U[54]  = -0.026041071738432
    U[55]  =  0.204040692499482;  U[56]  = -2.499999999999992
    U[57]  = -2.499999999999990;  U[58]  = -0.026041071738434
    U[59]  =  0.000000000000000;  U[60]  = -0.026041071738432
    U[61]  = -2.499999999999991;  U[62]  = -2.499999999999992
    U[63]  =  0.215858484880918;  U[64]  =  4.988182208251953
    U[65]  = -2.499999999999990;  U[66]  = -2.499999999999975
    U[67]  =  0.204040693132870;  U[68]  =  0.011817791748026
    U[69]  =  0.192222901384845;  U[70]  = -2.499999999999991
    U[71]  = -2.499999999999990;  U[72]  = -0.026041071737961
    U[73]  =  0.204040693132870;  U[74]  = -2.499999999999992
    U[75]  = -2.499999999999990;  U[76]  = -0.026041071737963
    U[77]  =  0.000000000000000;  U[78]  = -0.026041071737961
    U[79]  = -2.499999999999991;  U[80]  = -2.499999999999992
    U[81]  =  4.999999999996546;  U[82]  =  4.999999999999970
    U[83]  = -2.499999999999975;  U[84]  = -2.499999999999975
    U[85]  =  4.999999999996516;  U[86]  =  0.000000000000000
    U[87]  =  4.999999999996516;  U[88]  = -2.499999999999991
    U[89]  = -2.499999999999975;  U[90]  =  0.000000000000000
    U[91]  =  4.999999999996516;  U[92]  = -2.499999999999991
    U[93]  = -2.499999999999975;  U[94]  =  0.215858481060569
    U[95]  =  4.988182208251953;  U[96]  = -2.499999999999990
    U[97]  = -2.499999999999975;  U[98]  =  0.204040689312522
    U[99]  =  0.011817791748023;  U[100] =  0.192222897564498
    U[101] = -2.499999999999991;  U[102] = -2.499999999999990
    U[103] =  4.734672533390068;  U[104] =  0.204040689312522
    U[105] = -2.499999999999977;  U[106] = -2.499999999999990
    U[107] =  4.734672533390062;  U[108] =  0.000000000000000
    U[109] =  4.734672533390068;  U[110] = -2.499999999999991
    U[111] = -2.499999999999977;  U[112] =  4.999999999996870
    U[113] =  4.999999999999972;  U[114] = -2.499999999999975
    U[115] = -2.499999999999975;  U[116] =  4.999999999996843
    U[117] = -0.025968303070038;  U[118] =  4.999999999996843
    U[119] = -2.499999999999992;  U[120] = -2.499999999999975
    U[121] = -0.025968303070040;  U[122] =  0.000000000000000
    U[123] = -0.025968303070038;  U[124] = -2.499999999999991
    U[125] = -2.499999999999992;  U[126] =  4.999999999997699
    U[127] =  4.999999999999980;  U[128] = -2.499999999999975
    U[129] = -2.499999999999975;  U[130] =  4.999999999997678
    U[131] =  4.744923533081106;  U[132] =  4.999999999997678
    U[133] = -2.499999999999977;  U[134] = -2.499999999999975
    U[135] =  4.744923533081098;  U[136] =  0.000000000000000
    U[137] =  4.744923533081106;  U[138] = -2.499999999999991
    U[139] = -2.499999999999977;  U[140] =  0.000000000000000
    U[141] =  4.744923533081106;  U[142] = -2.499999999999991
    U[143] = -2.499999999999977;  U[144] =  0.215858484844162
    U[145] =  4.988182208251953;  U[146] = -2.499999999999990
    U[147] = -2.499999999999975;  U[148] =  0.204040693096114
    U[149] =  0.011817791748023;  U[150] =  0.192222901348091
    U[151] = -2.499999999999991;  U[152] = -2.499999999999990
    U[153] =  0.204040693096045;  U[154] =  0.204040693096107
    U[155] = -2.499999999999990;  U[156] = -2.499999999999990
    U[157] =  0.204040693096037;  U[158] =  0.000000000000000
    U[159] =  0.204040693096037;  U[160] = -2.499999999999991
    U[161] = -2.499999999999990;  U[162] = -0.026017361873565
    U[163] =  0.204040693096114;  U[164] = -2.499999999999992
    U[165] = -2.499999999999990;  U[166] = -0.026017361873568
    U[167] = -0.026017590106916;  U[168] = -0.026017361873565
    U[169] = -2.499999999999992;  U[170] = -2.499999999999992
    U[171] = -0.026017590106918;  U[172] =  0.000000000000000
    U[173] = -0.026017590106916;  U[174] = -2.499999999999991
    U[175] = -2.499999999999992

    # Compute initial charges
    G = zeros(175)
    GCN!(G, U)

    # Full state: y[1:175] = charges, y[176:350] = potentials
    y0 = zeros(350)
    y0[1:175]   .= G
    y0[176:350] .= U
    return y0
end

y0 = tba_initial_conditions()
println("Initial condition: 350 variables (175 charges + 175 potentials)")
println("  S0  (V₄₉)  = ", y0[224])
println("  S1  (V₁₃₀) = ", y0[305])
println("  C   (V₁₄₈) = ", y0[323])
```

## Mass-Matrix ODE Formulation

The DAE is written as `M·dy/dt = f(t, y)` where `M = diag(I₁₇₅, 0₁₇₅)`.
The first 175 equations are differential (charge conservation), and the
remaining 175 are algebraic (charge = g(V)).

```julia
function tba_rhs!(dy, y, p, t)
    @views begin
        x = y[176:350]
        # Differential equations: dQ/dt = f(t, V)
        FCN!(dy, t, x)              # writes dy[1:175]
        # Algebraic equations: 0 = Q - g(V)
        GCN!(dy[176:350], x)        # writes dy[176:350] = g(V)
        @. dy[176:350] = y[1:175] - dy[176:350]  # Q - g(V)
    end
end

# Mass matrix: identity for charges, zero for potentials
M_tba = zeros(350, 350)
for i in 1:175
    M_tba[i, i] = 1.0
end

tspan = (0.0, 320.0)
mmf = ODEFunction(tba_rhs!, mass_matrix = M_tba)
prob_mm = ODEProblem(mmf, y0, tspan)
```

## DAE Residual Form

The same system as a DAE residual `F(du, u, t) = M·du − f(u, t) = 0`,
for testing DAE-specific solvers like IDA.

```julia
function tba_dae!(res, du, u, p, t)
    tba_rhs!(res, u, p, t)
    @views begin
        @. res[1:175]   = du[1:175] - res[1:175]     # M*du - f (differential)
        @. res[176:350] = -res[176:350]               # 0 - (Q - g(V)) (algebraic)
    end
end

du0 = zeros(350)
tba_rhs!(du0, y0, nothing, 0.0)
# For consistent ICs: du0[176:350] should be zero (algebraic)
# and du0[1:175] = f(0, V0)
du0_dae = copy(du0)
du0_dae[176:350] .= 0.0

differential_vars = [trues(175); falses(175)]
prob_dae = DAEProblem(tba_dae!, du0_dae, y0, tspan,
                      differential_vars = differential_vars)
println("DAE problem: 350 variables, 175 differential + 175 algebraic")
```

## MTK Formulation via modelingtoolkitize

We convert the mass-matrix ODE to a ModelingToolkit system using
`modelingtoolkitize`, which enables symbolic Jacobian generation and
structural analysis. For a 350-variable circuit model with heavy
piecewise nonlinearities, this is the practical approach — full symbolic
rewrite of transistor equations would be prohibitive.

```julia
sys = modelingtoolkitize(prob_mm)
prob_mtk = ODEProblem(sys, [], tspan)
println("MTK system: $(length(ModelingToolkit.unknowns(sys))) unknowns")
```

## Reference Solution

We compute a high-accuracy reference using Rodas5P on the mass-matrix form
at tight tolerance. The IVP Test Set reference was computed with RADAU5
at rtol = atol = 1e-5; our reference must be significantly tighter to ensure
the WPD error floor is well below the tested tolerance range.

```julia
ref_sol = solve(prob_mm, Rodas5P(), reltol = 1e-10, abstol = 1e-10,
                maxiters = 10_000_000);
println("Reference solution: retcode = $(ref_sol.retcode), ",
        "npoints = $(length(ref_sol.t)), t_final = $(ref_sol.t[end])")

mtk_ref = solve(prob_mtk, Rodas5P(), reltol = 1e-10, abstol = 1e-10,
                maxiters = 10_000_000);
println("MTK reference: retcode = $(mtk_ref.retcode), ",
        "npoints = $(length(mtk_ref.t)), t_final = $(mtk_ref.t[end])")
```

## Output Signal Plots

The three physically relevant output signals are the digital outputs S0, S1,
and C. These correspond to node potentials V₄₉, V₁₃₀, V₁₄₈ (indices
224, 305, 323 in the full state vector).

```julia
plot(ref_sol, idxs = [224], title = "S₀ Output Signal (V₄₉)",
     xlabel = "Time", ylabel = "Voltage", lw = 1.5, legend = false)
```

```julia
plot(ref_sol, idxs = [305], title = "S₁ Output Signal (V₁₃₀)",
     xlabel = "Time", ylabel = "Voltage", lw = 1.5, legend = false)
```

```julia
plot(ref_sol, idxs = [323], title = "Carry Output Signal C (V₁₄₈)",
     xlabel = "Time", ylabel = "Voltage", lw = 1.5, legend = false)
```

```julia
plot(ref_sol, idxs = [224, 305, 323],
     title = "Two-Bit Adder: All Output Signals",
     xlabel = "Time", ylabel = "Voltage", lw = 1.5,
     label = ["S₀ (V₄₉)" "S₁ (V₁₃₀)" "C (V₁₄₈)"])
```

## Verification against IVP Test Set Reference

The `solut` subroutine provides reference values at t = 320. We verify
the three output components.

```julia
archimede_y224 = 0.2040419147264534   # x(49)  = y(224)
archimede_y305 = 0.4997238455712048e1 # x(130) = y(305)
archimede_y323 = 0.2038985905095614   # x(148) = y(323)

sol_final = ref_sol.u[end]
println("=== Verification at t = 320 ===")
println("Variable | ARCHIMEDE Reference       | Our Solution              | Rel Error")
println("-"^80)
for (name, idx, ref_val) in [("y(224) S₀", 224, archimede_y224),
                              ("y(305) S₁", 305, archimede_y305),
                              ("y(323) C ", 323, archimede_y323)]
    our_val = sol_final[idx]
    relerr = abs(ref_val) > 0 ? abs((our_val - ref_val) / ref_val) : abs(our_val)
    status = relerr < 1e-3 ? "✓" : (relerr < 1e-1 ? "~" : "✗")
    println("$(rpad(name, 12))| $(lpad(string(ref_val), 26)) | $(lpad(string(round(our_val, sigdigits=12)), 26)) | $(relerr) $status")
end
```

## Work-Precision Diagrams

We benchmark three formulations: DAE residual (IDA, DASKR, DASSL),
mass-matrix ODE (Rosenbrock-W, BDF), and MTK (Rosenbrock-W).

Per the IVP Test Set specification, error is measured only on the three
physically relevant output signals: S₀ (index 224), S₁ (index 305),
and C (index 323). This matches the original benchmark's scd computation.

```julia
probs = [prob_dae, prob_mm, prob_mtk]
refs  = [ref_sol, ref_sol, mtk_ref]

# Output signal indices for error measurement
const OUTPUT_IDXS = [224, 305, 323]
```

### High Tolerances

```julia
abstols = 1.0 ./ 10.0 .^ (2:7)
reltols = 1.0 ./ 10.0 .^ (1:6)
setups = [
    Dict(:prob_choice => 1, :alg => IDA()),
    Dict(:prob_choice => 2, :alg => Rodas5P()),
    Dict(:prob_choice => 2, :alg => Rodas4P()),
    Dict(:prob_choice => 2, :alg => FBDF()),
    Dict(:prob_choice => 2, :alg => QNDF()),
    Dict(:prob_choice => 2, :alg => RadauIIA5()),
    Dict(:prob_choice => 3, :alg => Rodas5P()),
]
labels = ["IDA (DAE)" "Rodas5P (MM)" "Rodas4P (MM)" "FBDF (MM)" "QNDF (MM)" "RadauIIA5 (MM)" "Rodas5P (MTK)"]

wp = WorkPrecisionSet(probs, abstols, reltols, setups;
    names = labels, appxsol = refs, save_everystep = false,
    maxiters = Int(1e6), numruns = 5, idxs = OUTPUT_IDXS)
plot(wp, title = "Two-Bit Adder: All Formulations (High Tol)")
```

### Medium Tolerances

```julia
abstols = 1.0 ./ 10.0 .^ (4:8)
reltols = 1.0 ./ 10.0 .^ (2:6)
setups = [
    Dict(:prob_choice => 1, :alg => IDA()),
    Dict(:prob_choice => 1, :alg => DASKR.daskr()),
    Dict(:prob_choice => 1, :alg => DASSL.dassl()),
    Dict(:prob_choice => 2, :alg => Rodas5P()),
    Dict(:prob_choice => 2, :alg => FBDF()),
    Dict(:prob_choice => 2, :alg => RadauIIA5()),
    Dict(:prob_choice => 3, :alg => Rodas5P()),
    Dict(:prob_choice => 3, :alg => Rodas4P()),
]
labels = ["IDA (DAE)" "DASKR (DAE)" "DASSL (DAE)" "Rodas5P (MM)" "FBDF (MM)" "RadauIIA5 (MM)" "Rodas5P (MTK)" "Rodas4P (MTK)"]

wp = WorkPrecisionSet(probs, abstols, reltols, setups;
    names = labels, appxsol = refs, save_everystep = false,
    maxiters = Int(1e6), numruns = 5, idxs = OUTPUT_IDXS)
plot(wp, title = "Two-Bit Adder: All Formulations (Medium Tol)")
```

### Timeseries Errors (L2)

```julia
abstols = 1.0 ./ 10.0 .^ (2:7)
reltols = 1.0 ./ 10.0 .^ (1:6)
setups = [
    Dict(:prob_choice => 1, :alg => IDA()),
    Dict(:prob_choice => 2, :alg => Rodas5P()),
    Dict(:prob_choice => 2, :alg => FBDF()),
    Dict(:prob_choice => 2, :alg => RadauIIA5()),
    Dict(:prob_choice => 3, :alg => Rodas5P()),
]
labels = ["IDA (DAE)" "Rodas5P (MM)" "FBDF (MM)" "RadauIIA5 (MM)" "Rodas5P (MTK)"]

wp = WorkPrecisionSet(probs, abstols, reltols, setups;
    names = labels, appxsol = refs, save_everystep = false,
    maxiters = Int(1e6), numruns = 5, error_estimate = :l2, idxs = OUTPUT_IDXS)
plot(wp, title = "Two-Bit Adder: Timeseries Error (L2)")
```

```julia, echo = false
using SciMLBenchmarks
SciMLBenchmarks.bench_footer(WEAVE_ARGS[:folder], WEAVE_ARGS[:file])
```
