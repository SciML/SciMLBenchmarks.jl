---
title: Slider-Crank DAE Work-Precision Diagrams
author: Singh Harsh Rahulkumar
---

This is a benchmark of the Slider-Crank mechanism with elastic connecting rod,
an index-2 DAE of dimension 24 from the IVP Test Set (Simeon 1998, `crank.f`).

The system models a crank-rod-slider mechanism where the connecting rod is
treated as a flexible beam with 4 finite-element modes (2 lateral, 2 axial).
The crank angle is prescribed as φ₁(t) = Ωt with Ω = 150 rad/s.

**Variables (17 in mass-matrix ODE form):**
- 7 positions: φ₁, φ₂, x₃, q₁, q₂, q₃, q₄
- 7 velocities: v₁, v₂, vx₃, vq₁, vq₂, vq₃, vq₄
- 3 Lagrange multipliers: λ₁, λ₂, λ₃

We formulate the index-2 DAE as a mass-matrix ODE and solve with
Rosenbrock-W type methods (Rodas5P, Rodas4P). The mass matrix is frozen
at t = 0, which limits achievable tolerance to around 1e-7.

Reference: Simeon, B.: Modelling a flexible slider crank mechanism by a mixed
system of DAEs and PDEs, Math. Modelling of Systems 2, 1-18 (1996).

```julia
using OrdinaryDiffEq, DiffEqDevTools, Plots
using LinearAlgebra

# ── Physical Parameters (from crank.f) ──────────────────────────────

const M1    = 0.36
const M2    = 0.151104
const M3    = 0.075552
const L1    = 0.15
const L2    = 0.30
const J1    = 0.002727
const J2    = 0.0045339259
const PI_   = 3.1415927
const EE    = 0.20e12
const NUE   = 0.30
const BB    = 0.0080
const HH    = 0.0080
const RHO   = 7870.0
const GRAV  = 0.0
const OMEGA = 150.0

const NQ = 4
const NP = 7
const NL = 3
const KU = 4
const KV = 0

# ── FE Matrices (exact port of FIRST block in RESMBS) ───────────────

function initialize_fe_matrices()
    FACM = RHO * BB * HH * L2
    FACK = EE * BB * HH / L2
    FACB = BB * HH * L2

    MQ_ = zeros(NQ, NQ)
    MQ_[1,1] = FACM * 0.5
    MQ_[2,2] = FACM * 0.5
    MQ_[3,3] = FACM * 8.0
    MQ_[3,4] = FACM * 1.0
    MQ_[4,3] = FACM * 1.0
    MQ_[4,4] = FACM * 2.0

    KQ_ = zeros(NQ, NQ)
    KQ_[1,1] = FACK * PI_^4 / 24.0 * (HH/L2)^2
    KQ_[2,2] = FACK * PI_^4 * 2.0 / 3.0 * (HH/L2)^2
    KQ_[3,3] = FACK * 16.0 / 3.0
    KQ_[3,4] = -FACK * 8.0 / 3.0
    KQ_[4,3] = -FACK * 8.0 / 3.0
    KQ_[4,4] = FACK * 7.0 / 3.0

    BQ_ = zeros(NQ, NQ)
    BQ_[1,3] = -FACB * 16.0 / PI_^3
    BQ_[1,4] =  FACB * (8.0 / PI_^3 - 1.0 / PI_)
    BQ_[2,4] =  FACB * 0.5 / PI_
    BQ_[3,1] =  FACB * 16.0 / PI_^3
    BQ_[4,1] = -FACB * (8.0 / PI_^3 - 1.0 / PI_)
    BQ_[4,2] = -FACB * 0.5 / PI_

    DQ_ = zeros(NQ, NQ)

    c1_  = zeros(NQ);  c2_  = zeros(NQ)
    c12_ = zeros(NQ);  c21_ = zeros(NQ)

    c1_[3]  = FACB * 2.0 / 3.0
    c1_[4]  = FACB * 1.0 / 6.0
    c2_[1]  = FACB * 2.0 / PI_
    c12_[3] = L2 * FACB * 1.0 / 3.0
    c12_[4] = L2 * FACB * 1.0 / 6.0
    c21_[1] = L2 * FACB * 1.0 / PI_
    c21_[2] = -L2 * FACB * 0.5 / PI_

    return MQ_, KQ_, BQ_, DQ_, c1_, c2_, c12_, c21_
end

const MQ, KQ, BQ, DQ, c1, c2, c12, c21 = initialize_fe_matrices()
```

## Consistent Initial Conditions

The Fortran reference code (`init1` in `crank.f`) provides positions and
velocities. We ensure full consistency by:
1. Using init1 positions (which satisfy the position-level constraints).
2. Projecting init1 velocities onto the constraint manifold via minimum-norm correction.
3. Computing consistent accelerations and Lagrange multipliers by solving the
   augmented saddle-point system `[AM GP'; GP 0] * [w; λ] = [F; γ]`.

```julia
function build_GP(p1, p2, q)
    cosp1 = cos(p1); sinp1 = sin(p1)
    cosp2 = cos(p2); sinp2 = sin(p2)
    qku = (KU == 0) ? 0.0 : q[KU]
    qkv = (KV == 0) ? 0.0 : q[KV]
    GP = zeros(3, NP)
    GP[1,1] = L1 * cosp1
    GP[1,2] = L2 * cosp2 + qku * cosp2 - qkv * sinp2
    GP[2,1] = L1 * sinp1
    GP[2,2] = L2 * sinp2 + qku * sinp2 + qkv * cosp2
    GP[2,3] = 1.0
    GP[3,1] = 1.0
    if KU != 0
        GP[1, 3+KU] = sinp2
        GP[2, 3+KU] = -cosp2
    end
    return GP
end

function build_AM(p1, p2, q)
    cosp12 = cos(p1 - p2); sinp12 = sin(p1 - p2)
    c1Tq = dot(c1, q); c2Tq = dot(c2, q)
    c12Tq = dot(c12, q); qtmqq = dot(q, MQ * q)
    QtBQ = zeros(NQ)
    for i in 1:NQ
        QtBQ[i] = dot(q, @view BQ[:, i])
    end

    AM = zeros(NP, NP)
    AM[1,1] = J1 + M2 * L1^2
    AM[1,2] = 0.5 * L1 * L2 * M2 * cosp12 +
              RHO * L1 * (sinp12 * c2Tq + cosp12 * c1Tq)
    AM[2,2] = J2 + qtmqq + 2.0 * RHO * c12Tq
    AM[3,3] = M3
    for i in 1:NQ
        AM[1, 3+i] = RHO * L1 * (-sinp12 * c1[i] + cosp12 * c2[i])
        AM[2, 3+i] = RHO * c21[i] + RHO * QtBQ[i]
    end
    for i in 1:NQ, j in 1:i
        AM[3+j, 3+i] = MQ[j, i]
    end
    for i in 1:NP, j in i+1:NP
        AM[j, i] = AM[i, j]
    end
    return AM
end

function compute_force_vector(p1, p2, q, v1, v2, vq)
    cosp12 = cos(p1 - p2); sinp12 = sin(p1 - p2)
    cosp1 = cos(p1); sinp1 = sin(p1)
    cosp2 = cos(p2); sinp2 = sin(p2)
    c1Tq = dot(c1, q); c1Tqd = dot(c1, vq)
    c2Tq = dot(c2, q); c2Tqd = dot(c2, vq)
    c12Tqd = dot(c12, vq)
    MQq = MQ * q; KQq = KQ * q; DQqd = DQ * vq; BQqd = BQ * vq
    qdtmqq = dot(vq, MQq); qdtbqqd = dot(vq, BQqd)

    F = zeros(NP)
    F[1] = -0.5 * L1 * GRAV * (M1 + 2.0 * M2) * cosp1 -
            0.5 * L1 * L2 * M2 * v2^2 * sinp12
    F[2] = -0.5 * L2 * GRAV * M2 * cosp2 +
            0.5 * L1 * L2 * M2 * v1^2 * sinp12
    F[3] = 0.0
    F[1] += RHO * L1 * v2^2 * (-sinp12 * c1Tq + cosp12 * c2Tq) -
            2.0 * RHO * L1 * v2 * (cosp12 * c1Tqd + sinp12 * c2Tqd)
    F[2] += RHO * L1 * v1^2 * (sinp12 * c1Tq - cosp12 * c2Tq) -
            2.0 * RHO * v2 * c12Tqd - 2.0 * v2 * qdtmqq -
            RHO * qdtbqqd - RHO * GRAV * (cosp2 * c1Tq - sinp2 * c2Tq)
    for i in 1:NQ
        F[3+i] = v2^2 * MQq[i] +
            RHO * (v2^2 * c12[i] + L1 * v1^2 * (cosp12 * c1[i] + sinp12 * c2[i]) +
                   2.0 * v2 * BQqd[i]) -
            RHO * GRAV * (sinp2 * c1[i] + cosp2 * c2[i])
        F[3+i] -= KQq[i] + DQqd[i]
    end
    return F
end

function get_consistent_ic()
    # Step 1: Positions from init1 (satisfy position constraints)
    p1 = 0.0;  p2 = 0.0;  x3 = 0.450016933
    q = [0.0, 0.0, 0.103339863e-04, 0.169327969e-04]
    pos = [p1, p2, x3, q...]

    # Step 2: Project init1 velocities onto constraint manifold
    v_init1 = [150.0, -74.9957670, -0.268938672e-05,
               0.444896105, 0.463434311e-02,
               -0.178591076e-05, -0.268938672e-05]
    GP0 = build_GP(p1, p2, q)
    target = [0.0, 0.0, OMEGA]
    residual_v = GP0 * v_init1 - target
    v_fixed = v_init1 - GP0' * ((GP0 * GP0') \ residual_v)

    # Step 3: Compute accelerations and multipliers
    AM0 = build_AM(p1, p2, q)
    F0 = compute_force_vector(p1, p2, q, v_fixed[1], v_fixed[2], v_fixed[4:7])

    # dGP/dt * v via finite differences
    eps_fd = 1e-8
    pos_p = pos .+ eps_fd .* v_fixed
    GP_p = build_GP(pos_p[1], pos_p[2], pos_p[4:7])
    dGPdt_v = (GP_p - GP0) / eps_fd * v_fixed

    # Augmented saddle-point system: [AM GP'; GP 0] [w; λ] = [F; -dGP/dt*v]
    n = NP + NL
    Aug = zeros(n, n)
    Aug[1:NP, 1:NP] = AM0
    Aug[1:NP, NP+1:n] = GP0'
    Aug[NP+1:n, 1:NP] = GP0
    rhs = zeros(n)
    rhs[1:NP] = F0
    rhs[NP+1:n] = -dGPdt_v
    sol = Aug \ rhs
    w_0 = sol[1:NP]
    lam_0 = sol[NP+1:n]

    return pos, v_fixed, w_0, lam_0, AM0, GP0
end

pos0, vel0, w0, lam0, AM0, GP0 = get_consistent_ic()

# Verify constraints
g1 = L1 * sin(pos0[1]) + (L2 + pos0[7]) * sin(pos0[2])
g2 = pos0[3] - L1 * cos(pos0[1]) - (L2 + pos0[7]) * cos(pos0[2])
g3 = pos0[1]
println("Position constraints: ", [g1, g2, g3])
println("Velocity constraint norm: ", norm(GP0 * vel0 - [0, 0, OMEGA]))
```

## Mass-Matrix ODE Formulation

The index-2 DAE is reformulated as a singular mass-matrix ODE with 17 state
variables `u = [p; v; λ]`. The mass matrix `M` has the structure:

```
M = [I   0   0 ]    du = [v            ]
    [0  AM   0 ]         [F - Gᵀλ      ]
    [0   0   0 ]         [G*v - r'(t)   ]
```

where `AM` is the 7×7 generalized mass matrix (frozen at t=0) and `G` is
the 3×7 constraint Jacobian (evaluated at current state).

```julia
function slider_crank_mm!(du, u, p, t)
    T = eltype(u)
    p1, p2, x3 = u[1], u[2], u[3]
    q  = @view u[4:7]
    v1, v2 = u[8], u[9]
    vq = @view u[11:14]
    lam1, lam2, lam3 = u[15], u[16], u[17]

    cosp1  = cos(p1);  sinp1  = sin(p1)
    cosp2  = cos(p2);  sinp2  = sin(p2)
    cosp12 = cos(p1 - p2);  sinp12 = sin(p1 - p2)

    qku = (KU == 0) ? zero(T) : q[KU]
    qkv = (KV == 0) ? zero(T) : q[KV]

    c1Tq   = dot(c1, q);    c1Tqd  = dot(c1, vq)
    c2Tq   = dot(c2, q);    c2Tqd  = dot(c2, vq)
    c12Tqd = dot(c12, vq)
    MQq  = MQ * q;   KQq  = KQ * q
    DQqd = DQ * vq;  BQqd = BQ * vq

    qtmqq   = dot(q, MQq)
    qdtmqq  = dot(vq, MQq)
    qdtbqqd = dot(vq, BQqd)

    QtBQ = zeros(T, NQ)
    for i in 1:NQ
        QtBQ[i] = dot(q, @view BQ[:, i])
    end

    # Constraint Jacobian GP (3×7) — evaluated at current state
    GP = zeros(T, 3, NP)
    GP[1,1] = L1 * cosp1
    GP[1,2] = L2 * cosp2 + qku * cosp2 - qkv * sinp2
    GP[2,1] = L1 * sinp1
    GP[2,2] = L2 * sinp2 + qku * sinp2 + qkv * cosp2
    GP[2,3] = one(T)
    GP[3,1] = one(T)
    if KU != 0
        GP[1, 3+KU] =  sinp2
        GP[2, 3+KU] = -cosp2
    end

    # Force vector F (7)
    F = zeros(T, NP)
    F[1] = -0.5 * L1 * GRAV * (M1 + 2.0 * M2) * cosp1 -
            0.5 * L1 * L2 * M2 * v2^2 * sinp12
    F[2] = -0.5 * L2 * GRAV * M2 * cosp2 +
            0.5 * L1 * L2 * M2 * v1^2 * sinp12
    F[3] = zero(T)

    F[1] += RHO * L1 * v2^2 * (-sinp12 * c1Tq + cosp12 * c2Tq) -
            2.0 * RHO * L1 * v2 * (cosp12 * c1Tqd + sinp12 * c2Tqd)
    F[2] += RHO * L1 * v1^2 * (sinp12 * c1Tq - cosp12 * c2Tq) -
            2.0 * RHO * v2 * c12Tqd - 2.0 * v2 * qdtmqq -
            RHO * qdtbqqd - RHO * GRAV * (cosp2 * c1Tq - sinp2 * c2Tq)

    for i in 1:NQ
        F[3+i] = v2^2 * MQq[i] +
            RHO * (v2^2 * c12[i] + L1 * v1^2 * (cosp12 * c1[i] + sinp12 * c2[i]) +
                   2.0 * v2 * BQqd[i]) -
            RHO * GRAV * (sinp2 * c1[i] + cosp2 * c2[i])
        F[3+i] -= KQq[i] + DQqd[i]
    end

    # Block 1 (rows 1:7): I * dp/dt = v
    for i in 1:7
        du[i] = u[7+i]
    end

    # Block 2 (rows 8:14): AM * dv/dt = F - Gᵀλ
    for i in 1:NP
        du[7+i] = F[i] - GP[1,i] * lam1 - GP[2,i] * lam2 - GP[3,i] * lam3
    end

    # Block 3 (rows 15:17): 0 * dλ/dt = G*v - r'(t)
    for k in 1:3
        vlc = zero(T)
        for i in 1:NP
            vlc += GP[k, i] * u[NP+i]
        end
        if k == 3
            vlc -= OMEGA
        end
        du[14+k] = vlc
    end
    nothing
end

function build_mass_matrix(AM)
    Mfull = zeros(17, 17)
    for i in 1:7
        Mfull[i, i] = 1.0        # identity block for dp/dt = v
    end
    Mfull[8:14, 8:14] .= AM      # AM block for dv/dt equations
    # rows 15:17 are zero → algebraic (velocity constraints)
    return Mfull
end

u0_mm = vcat(pos0, vel0, lam0)
M_mm = build_mass_matrix(AM0)
mmf = ODEFunction(slider_crank_mm!, mass_matrix = M_mm)
tspan = (0.0, 0.1)
prob_mm = ODEProblem(mmf, u0_mm, tspan)
```

## Reference Solution

We compute a high-accuracy reference solution using Rodas5P at moderate
tolerance. The frozen mass matrix limits how tight we can push tolerances
before instability sets in, so `reltol = abstol = 1e-6` provides the best
balance of accuracy and stability for this problem.

```julia
ref_sol = solve(prob_mm, Rodas5P(), reltol = 1e-6, abstol = 1e-6,
                maxiters = 10_000_000);
println("Reference solution: retcode = $(ref_sol.retcode), ",
        "npoints = $(length(ref_sol.t)), t_final = $(ref_sol.t[end])")
```

```julia
plot(ref_sol, idxs = [2, 3], title = "φ₂ and x₃",
     xlabel = "t", ylabel = "value", lw = 2)
```

```julia
plot(ref_sol, idxs = [4, 5], title = "Lateral Elastic Modes q₁, q₂",
     xlabel = "t", ylabel = "amplitude", lw = 2)
```

```julia
plot(ref_sol, idxs = [6, 7], title = "Axial Elastic Modes q₃, q₄",
     xlabel = "t", ylabel = "amplitude", lw = 2)
```

```julia
plot(ref_sol, idxs = [15, 16, 17], title = "Lagrange Multipliers λ₁, λ₂, λ₃",
     xlabel = "t", ylabel = "force", lw = 2)
```

## Work-Precision Diagrams

We compare Rosenbrock-W type solvers which handle the singular mass matrix
well. The tolerance range is 1e-4 to 1e-7 (tighter tolerances cause
instability due to the frozen mass matrix approximation).

### High Tolerances

```julia
abstols = 1.0 ./ 10.0 .^ (4:7)
reltols = 1.0 ./ 10.0 .^ (1:4);
setups = [
    Dict(:prob_choice => 1, :alg => Rodas5P()),
    Dict(:prob_choice => 1, :alg => Rodas4P()),
    Dict(:prob_choice => 1, :alg => Rodas4()),
    Dict(:prob_choice => 1, :alg => Rodas5()),
]

wp = WorkPrecisionSet([prob_mm], abstols, reltols, setups;
    save_everystep = false, appxsol = [ref_sol], maxiters = Int(1e7), numruns = 10)
plot(wp, title = "Slider-Crank: Work-Precision (High Tol)")
```

### Timeseries Errors

```julia
abstols = 1.0 ./ 10.0 .^ (4:7)
reltols = 1.0 ./ 10.0 .^ (1:4);
setups = [
    Dict(:prob_choice => 1, :alg => Rodas5P()),
    Dict(:prob_choice => 1, :alg => Rodas4P()),
    Dict(:prob_choice => 1, :alg => Rodas4()),
    Dict(:prob_choice => 1, :alg => Rodas5()),
]

wp = WorkPrecisionSet([prob_mm], abstols, reltols, setups; error_estimate = :l2,
    save_everystep = false, appxsol = [ref_sol], maxiters = Int(1e7), numruns = 10)
plot(wp, title = "Slider-Crank: Timeseries Error (L2)")
```

### Verification against ARCHIMEDE Reference

The IVP Test Set (`crank.f`, `solut` subroutine) provides reference values at
t = 0.1. We verify our solution reproduces these values.

```julia
archimede_refs = Dict(
    "φ₂"  => -0.331173498825626,
    "x₃"  =>  0.169737332842786,
    "q₁"  =>  0.1893192899613509e-3,
    "q₂"  =>  0.2375751249879174e-4,
    "q₃"  => -0.5323896770569702e-5,
    "q₄"  => -0.8363313279112129e-5,
    "λ₁"  => -62.32935833287916,
    "λ₂"  => -163.7920993367306,
    "λ₃"  =>  25.29857947066878,
)

# Mass-matrix form indices: [p(1:7), v(8:14), λ(15:17)]
idxmap = [("φ₂", 2), ("x₃", 3), ("q₁", 4), ("q₂", 5), ("q₃", 6), ("q₄", 7),
          ("λ₁", 15), ("λ₂", 16), ("λ₃", 17)]

sol_final = ref_sol.u[end]
println("=== Verification at t = 0.1 ===")
println("Variable    | ARCHIMEDE Reference  | Our Solution         | Rel Error")
println("-"^75)
for (name, idx) in idxmap
    ref_val = archimede_refs[name]
    our_val = sol_final[idx]
    relerr = abs(ref_val) > 0 ? abs((our_val - ref_val) / ref_val) : abs(our_val)
    status = relerr < 1e-3 ? "✓" : (relerr < 1e-1 ? "~" : "✗")
    println("$(rpad(name, 12))| $(lpad(string(ref_val), 21)) | $(lpad(string(round(our_val, sigdigits=10)), 21)) | $(relerr) $status")
end

# Overlay ARCHIMEDE reference point on q₁ timeseries
p_verify = plot(ref_sol, idxs = [4], title = "Verification: Elastic Mode q₁",
    xlabel = "Time (s)", ylabel = "Amplitude", lw = 2, label = "SciML Rodas5P")
scatter!(p_verify, [0.1], [0.1893192899613509e-3],
    label = "ARCHIMEDE Reference", color = :red, markersize = 8)
plot(p_verify)
```

```julia, echo = false
using SciMLBenchmarks
SciMLBenchmarks.bench_footer(WEAVE_ARGS[:folder], WEAVE_ARGS[:file])
```
