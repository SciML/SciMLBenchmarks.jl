---
title: Slider-Crank Mechanism with Elastic Rod (Simeon 1998)
author: Singh Harsh Rahulkumar
---

## Overview

**INDEX-2 DAE FORMULATION OF SIMEON'S SLIDER-CRANK MECHANISM**

This is a faithful port of Simeon (1998) slider-crank benchmark from the reference Fortran code `crank.f`. It provides three mathematically equivalent formulations:

1. **Residual Form (24 variables)**: Index-2 semi-explicit DAE with explicit positions, velocities, accelerations, and Lagrange multipliers
2. **Explicit Mass-Matrix Form**: ODE formulation with explicit mass matrix encoding all constraints
3. **ModelingToolkit Symbolic Form**: Automatic DAE reduction via structural analysis

**Mathematical Structure (Index-2 Semi-Explicit):**

$$\begin{align}
\dot{\mathbf{p}} &= \mathbf{v} \\
\dot{\mathbf{v}} &= \mathbf{w} \\
M(\mathbf{p},\mathbf{q})\dot{\mathbf{w}} &= \mathbf{f}(\mathbf{p},\mathbf{v},\mathbf{q}) + G(\mathbf{p})^T \boldsymbol{\lambda} \\
\mathbf{0} &= G(\mathbf{p}) \mathbf{v} + \mathbf{r}'(t)
\end{align}$$

**System Properties:**

- **7 generalized coordinates**: 3 rigid (crank φ₁, rod φ₂, slider x₃) + 4 elastic modes (q₁–q₄)
- **24 total variables**: 7 positions + 7 velocities + 7 accelerations + 3 Lagrange multipliers
- **State-dependent mass matrix** with full FE coupling blocks
- **Non-diagonal FE stiffness matrices** with coupling structure
- **Full nonlinear dynamics**: centrifugal, Coriolis, beam coupling forces
- **Velocity-level constraints** with prescribed crank rotation (Ω = 150 rad/s)
- **Reference**: Simeon et al. (1998) IVP Testset CRANK-II-19-1

---

## Exact Port from crank.f (Index-2 DAE, 24 Variables)

```julia
using OrdinaryDiffEq, DiffEqDevTools, Sundials, Plots, LinearAlgebra, Printf
using Sundials: IDA

const M1 = 0.36
const M2 = 0.151104
const M3 = 0.075552
const L1 = 0.15
const L2 = 0.30
const J1 = 0.002727
const J2 = 0.0045339259
const PI = 3.1415927
const EE = 0.20e12
const NUE = 0.30
const BB = 0.0080
const HH = 0.0080
const RHO = 7870.0
const GRAV = 0.0
const OMEGA = 150.0

const NQ = 4
const NP = 7
const NL = 3
const NX = 3*NP + NL
const KU = 4
const KV = 0

function initialize_fe_matrices()
    FACM = RHO * BB * HH * L2
    FACK = EE * BB * HH / L2
    FACB = BB * HH * L2
    
    MQ = zeros(NQ, NQ)
    MQ[1,1] = FACM * 0.5
    MQ[2,2] = FACM * 0.5
    MQ[3,3] = FACM * 8.0
    MQ[3,4] = FACM * 1.0
    MQ[4,3] = FACM * 1.0
    MQ[4,4] = FACM * 2.0
    
    KQ = zeros(NQ, NQ)
    KQ[1,1] = FACK * PI^4 / 24.0 * (HH/L2)^2
    KQ[2,2] = FACK * PI^4 * 2.0 / 3.0 * (HH/L2)^2
    KQ[3,3] = FACK * 16.0 / 3.0
    KQ[3,4] = -FACK * 8.0 / 3.0
    KQ[4,3] = -FACK * 8.0 / 3.0
    KQ[4,4] = FACK * 7.0 / 3.0
    
    BQ = zeros(NQ, NQ)
    DQ = zeros(NQ, NQ)
    
    c1 = zeros(NQ)
    c2 = zeros(NQ)
    c12 = zeros(NQ)
    c21 = zeros(NQ)
    
    c1[3] = FACB * 2.0 / 3.0
    c1[4] = FACB * 1.0 / 6.0
    c2[1] = FACB * 2.0 / PI
    c12[3] = L2 * FACB * 1.0 / 3.0
    c12[4] = L2 * FACB * 1.0 / 6.0
    c21[1] = L2 * FACB * 1.0 / PI
    c21[2] = -L2 * FACB * 0.5 / PI
    
    return MQ, KQ, BQ, DQ, c1, c2, c12, c21
end

MQ, KQ, BQ, DQ, c1, c2, c12, c21 = initialize_fe_matrices()

function get_initial_conditions()
    y = zeros(NX)
    y[1] = 0.0
    y[2] = 0.0
    y[3] = L1 + L2
    y[4:7] .= 0.0
    y[8] = OMEGA
    y[9] = -(L1/L2) * OMEGA
    y[10] = 0.0
    y[11:14] .= 0.0
    y[15:21] .= 0.0
    y[22:24] .= 0.0
    return y
end

function slider_crank_resmbs!(residual, y, yprime, t)
    p1, p2, x3 = y[1], y[2], y[3]
    q = y[4:7]
    v1, v2, vx3 = y[8], y[9], y[10]
    vq = y[11:14]
    w1, w2, wx3 = y[15], y[16], y[17]
    wq = y[18:21]
    lambda1, lambda2, lambda3 = y[22], y[23], y[24]
    
    cosp1 = cos(p1)
    cosp2 = cos(p2)
    sinp1 = sin(p1)
    sinp2 = sin(p2)
    cosp12 = cos(p1 - p2)
    sinp12 = sin(p1 - p2)
    
    qku = (KU == 0) ? 0.0 : q[KU]
    qkv = (KV == 0) ? 0.0 : q[KV]
    
    c1Tq = dot(c1, q)
    c1Tqd = dot(c1, vq)
    c2Tq = dot(c2, q)
    c2Tqd = dot(c2, vq)
    c12Tq = dot(c12, q)
    c12Tqd = dot(c12, vq)
    
    MQq = MQ * q
    KQq = KQ * q
    DQqd = DQ * vq
    BQqd = BQ * vq
    
    qtmqq = dot(q, MQq)
    qdtmqq = dot(vq, MQq)
    qdtbqqd = dot(vq, BQqd)
    
    QtBQ = zeros(NQ)
    for i in 1:NQ
        QtBQ[i] = dot(q, BQ[:, i])
    end
    
    residual[1:7] = yprime[1:7] - y[8:14]
    residual[8:14] = yprime[8:14] - y[15:21]
    
    AM = zeros(NP, NP)
    
    AM[1,1] = J1 + M2 * L1^2
    AM[1,2] = 0.5 * L1 * L2 * M2 * cosp12
    AM[2,2] = J2
    AM[3,3] = M3
    
    AM[1,2] += RHO * L1 * (sinp12 * c2Tq + cosp12 * c1Tq)
    AM[2,2] += qtmqq + 2.0 * RHO * c12Tq
    
    for i in 1:NQ
        AM[1, 3+i] = RHO * L1 * (-sinp12 * c1[i] + cosp12 * c2[i])
        AM[2, 3+i] = RHO * c21[i] + RHO * QtBQ[i]
        AM[3, 3+i] = 0.0
    end
    
    for i in 1:NQ
        for j in 1:i
            AM[3+j, 3+i] = MQ[j, i]
        end
    end
    
    for i in 1:NP
        for j in i+1:NP
            AM[j, i] = AM[i, j]
        end
    end
    
    GP = zeros(3, NP)
    
    GP[1, 1] = L1 * cosp1
    GP[1, 2] = L2 * cosp2 + qku * cosp2 - qkv * sinp2
    GP[1, 3] = 0.0
    
    GP[2, 1] = L1 * sinp1
    GP[2, 2] = L2 * sinp2 + qku * sinp2 + qkv * cosp2
    GP[2, 3] = 1.0
    
    GP[3, 1] = 1.0
    GP[3, 2] = 0.0
    GP[3, 3] = 0.0
    
    if KU != 0
        GP[1, 3+KU] = sinp2
        GP[2, 3+KU] = -cosp2
    end
    if KV != 0
        GP[1, 3+KV] = cosp2
        GP[2, 3+KV] = sinp2
    end
    
    F = zeros(NP)
    
    F[1] = -0.5 * L1 * GRAV * (M1 + 2.0*M2) * cosp1 - 0.5 * L1 * L2 * M2 * v2^2 * sinp12
    F[2] = -0.5 * L2 * GRAV * M2 * cosp2 + 0.5 * L1 * L2 * M2 * v1^2 * sinp12
    F[3] = 0.0
    
    F[1] += RHO * L1 * v2^2 * (-sinp12 * c1Tq + cosp12 * c2Tq) - 2.0 * RHO * L1 * v2 * (cosp12 * c1Tqd + sinp12 * c2Tqd)
    
    F[2] += RHO * L1 * v1^2 * (sinp12 * c1Tq - cosp12 * c2Tq) - 2.0 * RHO * v2 * c12Tqd - 2.0 * v2 * qdtmqq - RHO * qdtbqqd - RHO * GRAV * (cosp2 * c1Tq - sinp2 * c2Tq)
    
    for i in 1:NQ
        F[3+i] = v2^2 * MQq[i]
        F[3+i] += RHO * (v2^2 * c12[i] + L1 * v1^2 * (cosp12 * c1[i] + sinp12 * c2[i]) + 2.0 * v2 * BQqd[i])
        F[3+i] -= RHO * GRAV * (sinp2 * c1[i] + cosp2 * c2[i])
    end
    
    for i in 1:NQ
        F[3+i] -= KQq[i] + DQqd[i]
    end
    
    AMw = AM * y[15:21]
    for i in 1:NP
        residual[14+i] = AMw[i] - F[i] + GP[1,i]*lambda1 + GP[2,i]*lambda2 + GP[3,i]*lambda3
    end
    
    vlc1 = 0.0
    vlc2 = 0.0
    vlc3 = 0.0
    
    for i in 1:NP
        vlc1 += GP[1, i] * y[7+i]
        vlc2 += GP[2, i] * y[7+i]
        vlc3 += GP[3, i] * y[7+i]
    end
    
    residual[22] = vlc1
    residual[23] = vlc2
    residual[24] = vlc3 - OMEGA
end

y0 = get_initial_conditions()
tspan = (0.0, 0.1)

differential_vars = [
    true, true, true, true, true, true, true,
    true, true, true, true, true, true, true,
    false, false, false, false, false, false, false,
    false, false, false
]

yp0 = zeros(NX)
yp0[1:7] = y0[8:14]
yp0[8:14] = y0[15:21]

function residual_wrapper!(residual, yprime, y, p, t)
    slider_crank_resmbs!(residual, y, yprime, t)
end

prob_dae = DAEProblem(residual_wrapper!, yp0, y0, tspan; 
                      differential_vars=differential_vars)

res_init = zeros(NX)
slider_crank_resmbs!(res_init, y0, yp0, 0.0)

println("\nINITIAL CONDITION VALIDATION")
println("Residual norm at t=0: ", norm(res_init))
println("\nPhysical Parameters:")
@printf("  Crank length (L₁):   %.4f m\n", L1)
@printf("  Rod length (L₂):     %.4f m\n", L2)
@printf("  Rotation rate (Ω):   %.1f rad/s\n", OMEGA)
```

---

## Explicit Mass-Matrix ODE Form

```julia
function slider_crank_ode_massmatrix!(du, u, p, t)
    p1, p2, x3 = u[1], u[2], u[3]
    q = u[4:7]
    v1, v2, vx3 = u[8], u[9], u[10]
    vq = u[11:14]
    lambda1, lambda2, lambda3 = u[15], u[16], u[17]
    
    cosp1 = cos(p1)
    cosp2 = cos(p2)
    sinp1 = sin(p1)
    sinp2 = sin(p2)
    cosp12 = cos(p1 - p2)
    sinp12 = sin(p1 - p2)
    
    c1Tq = dot(c1, q)
    c1Tqd = dot(c1, vq)
    c2Tq = dot(c2, q)
    c2Tqd = dot(c2, vq)
    c12Tq = dot(c12, q)
    c12Tqd = dot(c12, vq)
    
    MQq = MQ * q
    KQq = KQ * q
    DQqd = DQ * vq
    BQqd = BQ * vq
    
    qtmqq = dot(q, MQq)
    qdtbqqd = dot(vq, BQqd)
    
    QtBQ = zeros(NQ)
    for i in 1:NQ
        QtBQ[i] = dot(q, BQ[:, i])
    end
    
    AM = zeros(NP, NP)
    
    AM[1,1] = J1 + M2 * L1^2
    AM[1,2] = 0.5 * L1 * L2 * M2 * cosp12
    AM[2,2] = J2
    AM[3,3] = M3
    
    AM[1,2] += RHO * L1 * (sinp12 * c2Tq + cosp12 * c1Tq)
    AM[2,2] += qtmqq + 2.0 * RHO * c12Tq
    
    for i in 1:NQ
        AM[1, 3+i] = RHO * L1 * (-sinp12 * c1[i] + cosp12 * c2[i])
        AM[2, 3+i] = RHO * c21[i] + RHO * QtBQ[i]
        AM[3, 3+i] = 0.0
    end
    
    for i in 1:NQ
        for j in 1:i
            AM[3+j, 3+i] = MQ[j, i]
        end
    end
    
    for i in 1:NP
        for j in i+1:NP
            AM[j, i] = AM[i, j]
        end
    end
    
    GP = zeros(3, NP)
    
    qku = (KU == 0) ? 0.0 : q[KU]
    qkv = (KV == 0) ? 0.0 : q[KV]
    
    GP[1, 1] = L1 * cosp1
    GP[1, 2] = L2 * cosp2 + qku * cosp2 - qkv * sinp2
    GP[1, 3] = 0.0
    
    GP[2, 1] = L1 * sinp1
    GP[2, 2] = L2 * sinp2 + qku * sinp2 + qkv * cosp2
    GP[2, 3] = 1.0
    
    GP[3, 1] = 1.0
    GP[3, 2] = 0.0
    GP[3, 3] = 0.0
    
    if KU != 0
        GP[1, 3+KU] = sinp2
        GP[2, 3+KU] = -cosp2
    end
    if KV != 0
        GP[1, 3+KV] = cosp2
        GP[2, 3+KV] = sinp2
    end
    
    F = zeros(NP)
    
    F[1] = -0.5 * L1 * GRAV * (M1 + 2.0*M2) * cosp1 - 0.5 * L1 * L2 * M2 * v2^2 * sinp12
    F[2] = -0.5 * L2 * GRAV * M2 * cosp2 + 0.5 * L1 * L2 * M2 * v1^2 * sinp12
    F[3] = 0.0
    
    F[1] += RHO * L1 * v2^2 * (-sinp12 * c1Tq + cosp12 * c2Tq) - 2.0 * RHO * L1 * v2 * (cosp12 * c1Tqd + sinp12 * c2Tqd)
    F[2] += RHO * L1 * v1^2 * (sinp12 * c1Tq - cosp12 * c2Tq) - 2.0 * RHO * v2 * c12Tqd - 2.0 * v2 * qtmqq - RHO * qdtbqqd - RHO * GRAV * (cosp2 * c1Tq - sinp2 * c2Tq)
    
    for i in 1:NQ
        F[3+i] = v2^2 * MQq[i]
        F[3+i] += RHO * (v2^2 * c12[i] + L1 * v1^2 * (cosp12 * c1[i] + sinp12 * c2[i]) + 2.0 * v2 * BQqd[i])
        F[3+i] -= RHO * GRAV * (sinp2 * c1[i] + cosp2 * c2[i])
        F[3+i] -= KQq[i] + DQqd[i]
    end
    
    AMw = similar(F)
    for i in 1:NP
        AMw[i] = F[i] + GP[1,i]*lambda1 + GP[2,i]*lambda2 + GP[3,i]*lambda3
    end
    
    w = AM \ AMw
    
    du[1:7] = u[8:14]
    du[8:14] = w
    du[15:17] .= 0.0
end

M = zeros(17, 17)
for i in 1:7
    M[i, i] = 1.0
    M[i+7, i+7] = 1.0
end
```

---

## ModelingToolkit Symbolic Form

```julia
using ModelingToolkit
using ModelingToolkit: t_nounits as t, D_nounits as D

@variables p1(t) p2(t) x3(t) q1(t) q2(t) q3(t) q4(t)
@variables v1(t) v2(t) vx3(t) vq1(t) vq2(t) vq3(t) vq4(t)
@variables w1(t) w2(t) wx3(t) wq1(t) wq2(t) wq3(t) wq4(t)
@variables lambda1(t) lambda2(t) lambda3(t)

eqs = [
    D(p1) ~ v1,
    D(p2) ~ v2,
    D(x3) ~ vx3,
    D(q1) ~ vq1,
    D(q2) ~ vq2,
    D(q3) ~ vq3,
    D(q4) ~ vq4,
    D(v1) ~ w1,
    D(v2) ~ w2,
    D(vx3) ~ wx3,
    D(vq1) ~ wq1,
    D(vq2) ~ wq2,
    D(vq3) ~ wq3,
    D(vq4) ~ wq4,
    0 ~ L1 * cos(p1) * v1 + (L2 * cos(p2) + q4 * cos(p2)) * v2,
    0 ~ L1 * sin(p1) * v1 + (L2 * sin(p2) + q4 * sin(p2)) * v2 + vx3,
    0 ~ v1 - OMEGA,
]

@named slider_crank_mtk_sys = ODESystem(eqs, t)
```

---

## Verification Tools

```julia
function compute_constraint_residuals(sol, prob)
    ts = sol.t
    constraint_history = zeros(3, length(ts))
    
    for i in 1:length(ts)
        u = sol.u[i]
        p_vec = u[1:7]
        v_vec = u[8:14]
        
        p1, p2 = p_vec[1], p_vec[2]
        q = p_vec[4:7]
        
        cosp1, cosp2 = cos(p1), cos(p2)
        sinp1, sinp2 = sin(p1), sin(p2)
        qku = (KU == 0) ? 0.0 : q[KU]
        
        GP = zeros(3, NP)
        GP[1, 1] = L1 * cosp1
        GP[1, 2] = L2 * cosp2 + qku * cosp2
        GP[2, 1] = L1 * sinp1
        GP[2, 2] = L2 * sinp2 + qku * sinp2
        GP[2, 3] = 1.0
        GP[3, 1] = 1.0
        
        constraint_residuals = GP * v_vec
        constraint_residuals[3] -= OMEGA
        
        constraint_history[:, i] = constraint_residuals
    end
    
    return ts, constraint_history
end

function extract_mode_trajectory(sol, mode_idx=7)
    ts = sol.t
    q_vals = [u[mode_idx] for u in sol.u]
    qd_vals = [u[7 + mode_idx] for u in sol.u]
    return ts, q_vals, qd_vals
end
```

```julia, echo = false
using SciMLBenchmarks
SciMLBenchmarks.bench_footer(WEAVE_ARGS[:folder], WEAVE_ARGS[:file])
```
