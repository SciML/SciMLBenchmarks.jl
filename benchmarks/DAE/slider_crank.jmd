---
title: Slider-Crank Mechanism (Rigid, Mass Matrix vs DAE)
author: Singh Harsh Rahulkumar
---

## Overview

The slider-crank mechanism is a classical constrained mechanical system that naturally leads to differential-algebraic equations (DAEs). This benchmark compares two formulations of the rigid slider-crank:

1. Mass-Matrix ODE Form: M * du = f(u)
2. Implicit DAE Form: F(du, u, t) = 0

The system models a crank driving a connecting rod and slider with geometric constraints.

---

## Problem Formulation

```julia
using OrdinaryDiffEq, DiffEqDevTools, Sundials, Plots, LinearAlgebra
using ModelingToolkit

# -----------------------------
# Physics Constants
# -----------------------------
const m_crank = 0.36
const m_rod = 0.151104
const m_slider = 0.075552
const l_crank = 0.15
const l_rod = 0.30
const J_crank = 0.002727
const J_rod = 0.0045339259

# -----------------------------
# MTK Structural Simplify Formulation
# -----------------------------

@parameters t
@variables theta(t) phi(t) x(t)
@variables dtheta(t) dphi(t) dx(t)
@variables λ1(t) λ2(t)

D = Differential(t)

eqs = [

    # Kinematics
    D(theta) ~ dtheta,
    D(phi)   ~ dphi,
    D(x)     ~ dx,

    # Dynamics
    J_crank*D(dtheta) ~ -(λ1*l_crank*cos(theta) - λ2*l_crank*sin(theta)),
    J_rod*D(dphi)     ~ -(λ1*l_rod*cos(phi) - λ2*l_rod*sin(phi)),
    m_slider*D(dx)    ~ -λ2,

    # Constraints
    0 ~ l_crank*sin(theta) - l_rod*sin(phi),
    0 ~ x - (l_crank*cos(theta) + l_rod*cos(phi))
]

@named slider_sys = ODESystem(eqs, t)

slider_sys_simplified = structural_simplify(slider_sys; dummy_derivative=false)

# -----------------------------
# Mass Matrix Formulation
# -----------------------------
function slider_crank_mm_f!(du, u, p, t)
    theta, phi, x = u[1], u[2], u[3]
    dtheta, dphi, dx = u[4], u[5], u[6]
    lam1, lam2 = u[7], u[8]

    # Kinematics
    du[1] = dtheta
    du[2] = dphi
    du[3] = dx

    # Dynamics
    du[4] = -(lam1 * l_crank * cos(theta) - lam2 * l_crank * sin(theta))
    du[5] = -(lam1 * l_rod * cos(phi) - lam2 * l_rod * sin(phi))
    du[6] = -lam2

    # Algebraic constraints
    du[7] = l_crank * sin(theta) - l_rod * sin(phi)
    du[8] = x - (l_crank * cos(theta) + l_rod * cos(phi))
end

# Singular Mass Matrix
M = zeros(8,8)
M[1,1] = 1.0
M[2,2] = 1.0
M[3,3] = 1.0
M[4,4] = J_crank
M[5,5] = J_rod
M[6,6] = m_slider

# -----------------------------
# DAE Residual Form
# -----------------------------
function slider_crank_dae_f!(res, du, u, p, t)
    slider_crank_mm_f!(res, u, p, t)
    mul!(res, M, du, 1.0, -1.0)   # res = M*du - f(u)
end

# -----------------------------
# Initialization
# -----------------------------
u0 = zeros(8)
u0[1] = π/2
u0[2] = asin((l_crank/l_rod)*sin(u0[1]))
u0[3] = l_crank*cos(u0[1]) + l_rod*cos(u0[2])
du0 = zeros(8)

tspan = (0.0, 0.5)

prob_mm = ODEProblem(ODEFunction(slider_crank_mm_f!, mass_matrix=M), u0, tspan)
prob_dae = DAEProblem(slider_crank_dae_f!, du0, u0, tspan,
                      differential_vars=[true,true,true,true,true,true,false,false])


# MTK Problem
# -----------------------------

phi0 = asin((l_crank/l_rod)*sin(π/2))
x0   = l_crank*cos(π/2) + l_rod*cos(phi0)

u0_mtk = [
    theta => π/2,
    phi   => phi0,
    x     => x0,
    dtheta => 0.0,
    dphi   => 0.0,
    dx     => 0.0,
    λ1     => 0.0,
    λ2     => 0.0
]

prob_mtk = ODEProblem(slider_sys_simplified, u0_mtk, tspan)


# -----------------------------
# Reference Solutions
# -----------------------------
println("Computing reference solutions...")
sol_ida   = solve(prob_dae, IDA(), abstol=1e-12, reltol=1e-12)
sol_rodas = solve(prob_mm,  Rodas5P(), abstol=1e-12, reltol=1e-12)
sol_mtk   = solve(prob_mtk, Rodas5P(), abstol=1e-12, reltol=1e-12)

# -----------------------------
# Verification Plot
# -----------------------------
p_verify = plot(sol_ida, idxs=3,
                label="IDA (DAE)", lw=4, alpha=0.6,
                title="Slider Position",
                xlabel="Time (s)", ylabel="x (m)")
plot!(p_verify, sol_rodas, idxs=3,
      label="Rodas5P (MM)", linestyle=:dash, lw=2)

plot!(p_verify, sol_mtk, idxs=3,
      label="Rodas5P (MTK)", linestyle=:dot, lw=2)

p_verify
probs = [prob_mm, prob_dae, prob_mtk]
refs  = [sol_rodas, sol_ida, sol_mtk]

abstols = 1.0 ./ 10.0 .^ (6:9)
reltols = 1.0 ./ 10.0 .^ (3:6)

setups = [
    Dict(:prob_choice=>1, :alg=>Rodas5P(),   :label=>"Rodas5P (MM)"),
    Dict(:prob_choice=>1, :alg=>RadauIIA5(), :label=>"RadauIIA5 (MM)"),
    Dict(:prob_choice=>2, :alg=>IDA(),       :label=>"IDA (Residual DAE)"),
    Dict(:prob_choice=>3, :alg=>Rodas5P(),   :label=>"Rodas5P (MTK)")
]

wp_high = WorkPrecisionSet(probs, abstols, reltols, setups;
                           save_everystep=false,
                           appxsol=refs,
                           maxiters=Int(1e5),
                           numruns=5)

plot(wp_high, title="Slider-Crank: Mass Matrix vs DAE (High Tol)")
abstols_low = 1.0 ./ 10.0 .^ (7:10)
reltols_low = 1.0 ./ 10.0 .^ (4:7)

wp_low = WorkPrecisionSet(probs, abstols_low, reltols_low, setups;
                          save_everystep=false,
                          appxsol=refs,
                          maxiters=Int(1e5),
                          numruns=3)

plot(wp_low, title="Slider-Crank: Mass Matrix vs DAE (Low Tol)")
if @isdefined(WEAVE_ARGS)
    using SciMLBenchmarks
    SciMLBenchmarks.bench_footer(WEAVE_ARGS[:folder], WEAVE_ARGS[:file])
end
