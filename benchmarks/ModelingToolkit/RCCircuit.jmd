---
title: RC Circuit
author: Avinash Subramanian, Yingbo Ma, Chris Elrod
---

When a model is defined using repeated components, JuliaSimCompiler is able to take advantage of this
to scale efficiently by rerolling equations into loops. This option can be disabled by setting `loop=false`.
Here, we build an RC circuit model with variable numbers of components to show scaling of compile and
runtimes of MTK vs JuliaSimCompiler's three backends with and without loop rerolling.

## Setup Model Code

```julia
using JuliaSimCompiler, ModelingToolkit, OrdinaryDiffEq, BenchmarkTools,
      ModelingToolkitStandardLibrary, OMJulia, CairoMakie
using ModelingToolkitStandardLibrary.Blocks
using ModelingToolkitStandardLibrary.Electrical
```

```julia
# ModelingToolkit and JuliaSimCompiler
const t = Blocks.t

function build_system(n)
    systems = @named begin
        sine = Sine(frequency = 10)
        source = Voltage()
        resistors[1:n] = Resistor()
        capacitors[1:n] = Capacitor()
        ground = Ground()
    end
    systems = reduce(vcat, systems)
    eqs = [connect(sine.output, source.V)
           connect(source.p, resistors[1].p)
           [connect(resistors[i].n, resistors[i + 1].p, capacitors[i].p)
            for i in 1:(n - 1)]
           connect(resistors[end].n, capacitors[end].p)
           [connect(capacitors[i].n, source.n) for i in 1:n]
           connect(source.n, ground.g)]
    @named sys = ODESystem(eqs, t; systems)
    u0 = [capacitors[i].v => float(i) for i in 1:n];
    ps = [[resistors[i].R => 1 / i for i in 1:n];
          [capacitors[i].C => 1 / i^2 for i in 1:n]]
    return sys, u0, ps
end

function compile_run_problem(
        sys, u0, ps; target = JuliaSimCompiler.JuliaTarget(), duref = nothing)
    tspan = (0.0, 10.0)
    t0 = time()
    prob = if target === JuliaSimCompiler.JuliaTarget()
        ODEProblem(sys, u0, tspan, ps; sparse = true)
    else
        ODEProblem(sys, target, u0, tspan, ps; sparse = true)
    end
    (; f, u0, p) = prob
    ff = f.f
    du = similar(u0)
    ff(du, u0, p, 0.0)
    t_fode = time() - t0
    duref === nothing || @assert duref â‰ˆ du
    t_run = @belapsed $ff($du, $u0, $p, 0.0)
    t_solve = @elapsed sol = solve(prob, Rodas5(autodiff = false))
    @assert SciMLBase.successful_retcode(sol)
    (t_fode, t_run, t_solve), du
end

const C = JuliaSimCompiler.CTarget();
const LLVM = JuliaSimCompiler.llvm.LLVMTarget();

function run_and_time_julia!(ss_times, times, max_sizes, i, n)
    sys, u0, ps = build_system(n);
    if n <= max_sizes[1]
        ss_times[i, 1] = @elapsed sys_mtk = structural_simplify(sys)
        times[i, 1], _ = compile_run_problem(sys_mtk, u0, ps)
    end
    ss_times[i, 2] = @elapsed sys_jsir_scalar = structural_simplify(IRSystem(sys), loop = false)
    ss_times[i, 3] = @elapsed sys_jsir_loop = structural_simplify(JuliaSimCompiler.compressed_connection_expansion(sys))
    oderef = daeref = nothing
    n <= max_sizes[2] && ((times[i, 2],
        oderef) = compile_run_problem(sys_jsir_scalar, u0, ps; duref = oderef))
    n <= max_sizes[3] && ((times[i, 3],
        oderef) = compile_run_problem(sys_jsir_scalar, u0, ps; target = C, duref = oderef))
    n <= max_sizes[4] && ((times[i, 4],
        oderef) = compile_run_problem(
        sys_jsir_scalar, u0, ps; target = LLVM, duref = oderef))
    n <= max_sizes[5] &&
        ((times[i, 5], deeref) = compile_run_problem(sys_jsir_loop, u0, ps; duref = daeref))
    n <= max_sizes[6] && ((times[i, 6],
        daeref) = compile_run_problem(sys_jsir_loop, u0, ps; target = C, duref = daeref))
    n <= max_sizes[7] && ((times[i, 7],
        daeref) = compile_run_problem(sys_jsir_loop, u0, ps; target = LLVM, duref = daeref))
    for j in 1:7
        ss_time = j == 1 ? ss_times[i, 1] : ss_times[i, 2 + (j >= 5)]
        t_fode, t_run, t_solve = times[i, j]
        total_times[i, j] = ss_time + t_fode + t_solve
    end
end
```

```julia
N = [5, 10, 20, 40, 60, 80, 160, 320, 480, 640, 800, 1000, 2000,
    3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 20000];

# max size we test per method
max_sizes = [4_000, 8_000, 20_000, 20_000, 20_000, 20_000, 20_000, 9000];

# NaN-initialize so Makie will ignore incomplete
ss_times = fill(NaN, length(N), 3);
times = fill((NaN, NaN, NaN), length(N), length(max_sizes) - 1);
total_times = fill(NaN, length(N), length(max_sizes) + 1);
```

## Julia Timings

```julia
@time run_and_time_julia!(ss_times, times, max_sizes, 1, 4); # precompile
for (i, n) in enumerate(N)
    @time run_and_time_julia!(ss_times, times, max_sizes, i, n)
end
```

## OpenModelica Timings

```julia
# OMJ
const omod = OMJulia.OMCSession();
OMJulia.sendExpression(omod, "getVersion()")
OMJulia.sendExpression(omod, "installPackage(Modelica)")
const modelicafile = joinpath(@__DIR__, "RC_Circuit.mo")

function time_open_modelica(n::Int)
    totaltime = @elapsed res = begin
        @sync ModelicaSystem(omod, modelicafile, "RC_Circuit.Test.RC_Circuit_MTK_test_$n")
        sendExpression(omod, "simulate(RC_Circuit.Test.RC_Circuit_MTK_test_$n)")
    end
    @assert res["messages"][1:11] == "LOG_SUCCESS"
    return totaltime
end

function run_and_time_om!(ss_times, times, max_sizes, i, n)
    if n <= max_sizes[8]
        total_times[i, end] = time_open_modelica(n)
    end
    @views println("n = $(n)\nstructural_simplify_times = $(ss_times[i,:])\ncomponent times = $(times[i, :])\ntotal times = $(total_times[i, :])")
end

for (i, n) in enumerate(N)
    @time run_and_time_om!(ss_times, times, max_sizes, i, n)
end

OMJulia.quit(omod)
```

## Dymola Timings

Dymola requires a license server and thus cannot be hosted. This was run locally for the
following times:

```julia
translation_and_total_times = [5 2.428 2.458
                               10 2.727 2.757
                               20 1.764 1.797
                               40 1.849 1.885
                               60 1.953 1.995
                               80 2.041 2.089
                               160 2.422 2.485
                               320 3.157 3.258
                               480 3.943 4.092
                               640 4.718 4.912
                               800 5.531 5.773
                               1000 6.526 6.826
                               2000 11.467 12.056
                               3000 16.8 17.831
                               4000 22.355 24.043
                               5000 27.768 30.083
                               6000 33.561 36.758
                               7000 39.197 43.154
                               8000 45.194 52.153
                               9000 50.689 57.187
                               10000 NaN NaN
                               20000 NaN NaN]

total_times[:, 9] = translation_and_total_times[:, 3]
```

## Results

```julia
f = Figure(size = (800, 1200));
ss_names = ["MTK", "JSIR-Scalar", "JSIR-Loop"];
let ax = Axis(f[1, 1]; yscale = log10, xscale = log10, title = "Structural Simplify Time")
    _lines = map(eachcol(ss_times)) do ts
        lines!(N, ts)
    end
    Legend(f[1, 2], _lines, ss_names)
end
method_names = ["MTK", "JSIR - Scalar - Julia", "JSIR - Scalar - C", "JSIR - Scalar - LLVM",
    "JSIR - Loop - Julia", "JSIR - Loop - C", "JSIR - Loop - LLVM"];
for (i, timecat) in enumerate(("ODEProblem + f!", "Run", "Solve"))
    title = timecat * " Time"
    ax = Axis(f[i + 1, 1]; yscale = log10, xscale = log10, title)
    _lines = map(eachcol(times)) do ts
        lines!(N, getindex.(ts, i))
    end
    Legend(f[i + 1, 2], _lines, method_names)
end
f
```

```julia
f2 = Figure(size = (800, 400));
title = "Total Time: RC Circuit Benchmark"
ax = Axis(f2[1, 1]; yscale = log10, xscale = log10, title)
names = ["MTK", "JSIR - Scalar - Julia", "JSIR - Scalar - C",
    "JSIR - Scalar - LLVM", "JSIR - Loop - Julia", "JSIR - Loop - C",
    "JSIR - Loop - LLVM", "OpenModelica", "Dymola"]
_lines = map(enumerate(names)) do (j, label)
    ts = @view(total_times[:, j])
    lines!(N, ts)
end
Legend(f2[1, 2], _lines, names)
f2
```

All three backends compiled more quickly with loops, but the C and LLVM backends are so much quicker to compile than the Julia backend that this made much less difference for them.
The impact on runtime was more varied.

## Appendix

```julia, echo = false
using SciMLBenchmarks
SciMLBenchmarks.bench_footer(WEAVE_ARGS[:folder], WEAVE_ARGS[:file])
```
