---
title: Ill-Conditioned Nonlinear System Work-Precision Diagrams
author: Avik Pal
---

# Setup

Fetch required packages

```julia
using NonlinearSolve, NLsolve, MINPACK, SparseDiffTools, Sundials
using LinearAlgebra, SparseArrays, DiffEqDevTools, CairoMakie, Symbolics
using BenchmarkTools
RUS = RadiusUpdateSchemes;
```

Define a utility to timeout the benchmark after a certain time.

```julia
macro timeout(seconds, expr, fail = nothing)
    quote
        tsk = @task $(esc(expr))
        schedule(tsk)
        Timer($(esc(seconds))) do timer
            istaskdone(tsk) || Base.throwto(tsk, InterruptException())
        end
        try
            fetch(tsk)
        catch err
            Base.printstyled("Timed Out.\n"; color = :red)
            $(esc(fail))
        end
    end
end
```

Define the Brussletor problem.

```julia
brusselator_f(x, y) = (((x - 3 // 10) ^ 2 + (y - 6 // 10) ^ 2) ≤ 0.01) * 5

limit(a, N) = ifelse(a == N + 1, 1, ifelse(a == 0, N, a))

function init_brusselator_2d(xyd, N)
    N = length(xyd)
    u = zeros(N, N, 2)
    for I in CartesianIndices((N, N))
        x = xyd[I[1]]
        y = xyd[I[2]]
        u[I, 1] = 22 * (y * (1 - y))^(3 / 2)
        u[I, 2] = 27 * (x * (1 - x))^(3 / 2)
    end
    return u
end

function generate_brusselator_problem(N::Int; sparsity = nothing, kwargs...)
    xyd_brusselator = range(0; stop = 1, length = N)

    function brusselator_2d_loop(du_, u_, p)
        A, B, α, δx = p
        α = α / δx ^ 2

        du = reshape(du_, N, N, 2)
        u = reshape(u_, N, N, 2)

        @inbounds for I in CartesianIndices((N, N))
            i, j = Tuple(I)
            x, y = xyd_brusselator[I[1]], xyd_brusselator[I[2]]
            ip1, im1 = limit(i + 1, N), limit(i - 1, N)
            jp1, jm1 = limit(j + 1, N), limit(j - 1, N)

            du[i, j, 1] = α * (u[im1, j, 1] + u[ip1, j, 1] + u[i, jp1, 1] + u[i, jm1, 1] -
                               4u[i, j, 1]) +
                          B + u[i, j, 1] ^ 2 * u[i, j, 2] - (A + 1) * u[i, j, 1] +
                          brusselator_f(x, y)

            du[i, j, 2] = α * (u[im1, j, 2] + u[ip1, j, 2] + u[i, jp1, 2] + u[i, jm1, 2] -
                               4u[i, j, 2]) +
                            A * u[i, j, 1] - u[i, j, 1] ^ 2 * u[i, j, 2]
        end
        return nothing
    end

    p = (3.4, 1.0, 10.0, step(xyd_brusselator))

    u0 = init_brusselator_2d(xyd_brusselator, N)

    nlfunc = NonlinearFunction(brusselator_2d_loop; sparsity)
    return NonlinearProblem(nlfunc, vec(u0), p; kwargs...)
end
```

# Scaling with Problem Size

First, let us experiment the scaling of each algorithm with the problem size.

```julia
Ns = 2 .^ (2:6)
solver_names = ["NewtonRaphson (Dense)", "NewtonRaphson (Approximate Sparse)",
    "NewtonRaphson (Exact Sparse)", "TrustRegion (Dense)",
    "TrustRegion (Approximate Sparse)", "TrustRegion (Exact Sparse)",
    "KINSOL", "NLsolveJL (Trust Region)", "SimpleNewtonRaphson",
    "SimpleTrustRegion", "CMINPACK"]
runtimes_scaling = zeros(length(solver_names), length(Ns)) .- 1
prob_alg_mapping = [
    (:dense, NewtonRaphson()), (:approx, NewtonRaphson()), (:exact, NewtonRaphson()),
    (:dense, TrustRegion()), (:approx, TrustRegion()), (:exact, TrustRegion()),
    (:dense, KINSOL()), (:dense, NLsolveJL()), (:dense, SimpleNewtonRaphson()),
    (:dense, SimpleTrustRegion()), (:dense, CMINPACK())]

for (i, N) in enumerate(Ns)
    prob_dense = generate_brusselator_problem(N; abstol=1e-6, reltol=1e-6)
    prob_approx_sparse = generate_brusselator_problem(N;
        sparsity = ApproximateJacobianSparsity(), abstol=1e-6, reltol=1e-6)
    prob_exact_sparse = generate_brusselator_problem(N;
        sparsity = SymbolicsSparsityDetection(), abstol=1e-6, reltol=1e-6)

    println("Benchmarking N = $N")

    for (j, (ptype, alg)) in enumerate(prob_alg_mapping)
        if ptype == :dense
            prob = prob_dense
        elseif ptype == :approx
            prob = prob_approx_sparse
        elseif ptype == :exact
            prob = prob_exact_sparse
        end

        if (j > 1 && runtimes_scaling[j - 1, i] == -1) || (N > 32 && alg isa CMINPACK) # CMINPACK is pretty worthless and our macro doesn't work with it
            # The last benchmark failed so skip this too
            runtimes_scaling[j, i] = NaN
            println("    $(solver_names[j]): Would Have Timed out")
        else
            @timeout 600 begin
                sol = solve(prob, alg)
                runtimes_scaling[j, i] = @belapsed solve($prob, $alg)
                println("    $(solver_names[j]): ", runtimes_scaling[j, i],
                    " resid = ", norm(sol.resid), " retcode = ", sol.retcode,
                    " stats = ", sol.stats)
            end
            if runtimes_scaling[j, i] == -1
                println("    $(solver_names[j]): Timed out")
                runtimes_scaling[j, i] = NaN
            end
        end
    end

    println()
end
```

Plot the results.

```julia
cycle = Cycle([:color, :linestyle, :marker], covary = true)
theme = merge(theme_latexfonts(), Theme(Lines = (cycle = cycle,),
    Scatter = (cycle = cycle,)))

fig = with_theme(theme; fontsize = 32) do 
    fig = Figure(; size = (1300, 1000))
    ax = Axis(fig[1, 1], ylabel = L"Time ($s$)", xlabel = L"Problem Size ($N$)",
        xscale = log2, yscale = log2, title = "Brusselator 2D: Scaling with Problem Size",
        )

    ls, scs = [], []
    for (i, solver_name) in enumerate(solver_names)
        push!(ls, lines!(Ns, runtimes_scaling[i, :]; linewidth = 3))
        push!(scs, scatter!(Ns, runtimes_scaling[i, :]; markersize = 16, strokewidth = 2))
    end

    Legend(fig[2, 1], [[l, sc] for (l, sc) in zip(ls, scs)],
        solver_names, position = :ct, color = :white, framevisible=false, label = "Solvers",
        orientation = :horizontal, tellwidth = false, tellheight = true, nbanks = 4,
        labelsize = 20)

    return fig
end
```

```julia
save("brusselator_scaling.svg", fig)
```